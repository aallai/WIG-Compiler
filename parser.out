Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> service
Rule 1     service -> SERVICE { htmls schemas variables functions sessions }
Rule 2     htmls -> html
Rule 3     htmls -> html htmls
Rule 4     html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
Rule 5     html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;
Rule 6     nehtmlbodies -> htmlbody
Rule 7     nehtmlbodies -> htmlbody nehtmlbodies
Rule 8     htmlbody -> START_TAG IDENTIFIER attributes END_TAG
Rule 9     htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG
Rule 10    htmlbody -> START_HOLE IDENTIFIER END_HOLE
Rule 11    htmlbody -> WHATEVER
Rule 12    htmlbody -> META
Rule 13    htmlbody -> START_TAG INPUT attributes END_TAG
Rule 14    htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
Rule 15    attributes -> <empty>
Rule 16    attributes -> neattributes
Rule 17    neattributes -> attribute
Rule 18    neattributes -> attribute neattributes
Rule 19    attribute -> attr
Rule 20    attribute -> attr = attr
Rule 21    attr -> IDENTIFIER
Rule 22    attr -> STRING_LITERAL
Rule 23    schemas -> <empty>
Rule 24    schemas -> neschemas
Rule 25    neschemas -> schema
Rule 26    neschemas -> schema neschemas
Rule 27    schema -> SCHEMA IDENTIFIER { fields }
Rule 28    fields -> <empty>
Rule 29    fields -> nefields
Rule 30    nefields -> field
Rule 31    nefields -> field nefields
Rule 32    field -> simpletype IDENTIFIER ;
Rule 33    variables -> <empty>
Rule 34    variables -> nevariables
Rule 35    nevariables -> variable
Rule 36    nevariables -> variable nevariables
Rule 37    variable -> type identifiers ;
Rule 38    identifiers -> IDENTIFIER
Rule 39    identifiers -> IDENTIFIER , identifiers
Rule 40    simpletype -> INT
Rule 41    simpletype -> BOOL
Rule 42    simpletype -> STRING
Rule 43    simpletype -> VOID
Rule 44    type -> simpletype
Rule 45    type -> TUPLE IDENTIFIER
Rule 46    functions -> <empty>
Rule 47    functions -> nefunctions
Rule 48    nefunctions -> function
Rule 49    nefunctions -> function nefunctions
Rule 50    function -> type IDENTIFIER ( arguments ) compoundstm
Rule 51    arguments -> <empty>
Rule 52    arguments -> nearguments
Rule 53    nearguments -> argument
Rule 54    nearguments -> argument , nearguments
Rule 55    argument -> type IDENTIFIER
Rule 56    sessions -> session
Rule 57    sessions -> session sessions
Rule 58    session -> SESSION IDENTIFIER ( ) compoundstm
Rule 59    stms -> <empty>
Rule 60    stms -> nestms
Rule 61    nestms -> stm
Rule 62    nestms -> stm nestms
Rule 63    stm -> ;
Rule 64    stm -> SHOW document receive ;
Rule 65    stm -> EXIT document ;
Rule 66    stm -> RETURN ;
Rule 67    stm -> RETURN exp ;
Rule 68    stm -> IF ( exp ) compoundstm
Rule 69    stm -> IF ( exp ) compoundstm ELSE compoundstm
Rule 70    stm -> WHILE ( exp ) compoundstm
Rule 71    stm -> compoundstm
Rule 72    stm -> exp ;
Rule 73    document -> IDENTIFIER
Rule 74    document -> PLUG IDENTIFIER [ plugs ]
Rule 75    receive -> <empty>
Rule 76    receive -> RECEIVE [ inputs ]
Rule 77    compoundstm -> { variables stms }
Rule 78    plugs -> plug
Rule 79    plugs -> plug , plugs
Rule 80    plug -> IDENTIFIER = exp
Rule 81    inputs -> <empty>
Rule 82    inputs -> neinputs
Rule 83    neinputs -> input
Rule 84    neinputs -> input , neinputs
Rule 85    input -> lvalue = IDENTIFIER
Rule 86    exp -> lvalue = exp
Rule 87    exp -> exp EQ exp
Rule 88    exp -> exp NEQ exp
Rule 89    exp -> exp < exp
Rule 90    exp -> exp > exp
Rule 91    exp -> exp LTEQ exp
Rule 92    exp -> exp GTEQ exp
Rule 93    exp -> exp + exp
Rule 94    exp -> exp - exp
Rule 95    exp -> exp * exp
Rule 96    exp -> exp / exp
Rule 97    exp -> exp % exp
Rule 98    exp -> exp AND exp
Rule 99    exp -> exp OR exp
Rule 100   exp -> exp LSHIFT exp
Rule 101   exp -> exp TADD IDENTIFIER
Rule 102   exp -> exp TADD ( identifiers )
Rule 103   exp -> exp TSUB IDENTIFIER
Rule 104   exp -> exp TSUB ( identifiers )
Rule 105   exp -> - exp
Rule 106   exp -> ! exp
Rule 107   exp -> lvalue
Rule 108   exp -> IDENTIFIER ( exps )
Rule 109   exp -> STRING_LITERAL
Rule 110   exp -> TRUE
Rule 111   exp -> FALSE
Rule 112   exp -> INT_LITERAL
Rule 113   exp -> TUPLE { fieldvalues }
Rule 114   exp -> ( exp )
Rule 115   exps -> <empty>
Rule 116   exps -> neexps
Rule 117   neexps -> exp
Rule 118   neexps -> exp , neexps
Rule 119   lvalue -> IDENTIFIER
Rule 120   lvalue -> IDENTIFIER . IDENTIFIER
Rule 121   fieldvalues -> <empty>
Rule 122   fieldvalues -> nefieldvalues
Rule 123   nefieldvalues -> fieldvalue
Rule 124   nefieldvalues -> fieldvalue , fieldvalues
Rule 125   fieldvalue -> IDENTIFIER = exp

Terminals, with rules where they appear

!                    : 106
%                    : 97
(                    : 50 58 68 69 70 102 104 108 114
)                    : 50 58 68 69 70 102 104 108 114
*                    : 95
+                    : 93
,                    : 39 54 79 84 118 124
-                    : 94 105
.                    : 120
/                    : 96
;                    : 4 5 32 37 63 64 65 66 67 72
<                    : 89
=                    : 4 5 20 80 85 86 125
>                    : 90
AND                  : 98
BOOL                 : 41
CONST                : 4 5
ELSE                 : 69
END_HOLE             : 10
END_HTML_LITERAL     : 4 5
END_TAG              : 8 9 13 14 14
EQ                   : 87
EXIT                 : 65
FALSE                : 111
GTEQ                 : 92
HTML                 : 4 5
IDENTIFIER           : 4 5 8 9 10 21 27 32 38 39 45 50 55 58 73 74 80 85 101 103 108 119 120 120 125
IF                   : 68 69
INPUT                : 13
INT                  : 40
INT_LITERAL          : 112
LSHIFT               : 100
LTEQ                 : 91
META                 : 12
NEQ                  : 88
OR                   : 99
PLUG                 : 74
RECEIVE              : 76
RETURN               : 66 67
SCHEMA               : 27
SELECT               : 14 14
SERVICE              : 1
SESSION              : 58
SHOW                 : 64
START_CLOSE_TAG      : 9 14
START_HOLE           : 10
START_HTML_LITERAL   : 4 5
START_TAG            : 8 13 14
STRING               : 42
STRING_LITERAL       : 22 109
TADD                 : 101 102
TRUE                 : 110
TSUB                 : 103 104
TUPLE                : 45 113
VOID                 : 43
WHATEVER             : 11
WHILE                : 70
[                    : 74 76
]                    : 74 76
error                : 
{                    : 1 27 77 113
}                    : 1 27 77 113

Nonterminals, with rules where they appear

argument             : 53 54
arguments            : 50
attr                 : 19 20 20
attribute            : 17 18
attributes           : 8 13 14
compoundstm          : 50 58 68 69 69 70 71
document             : 64 65
exp                  : 67 68 69 70 72 80 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 102 103 104 105 106 114 117 118 125
exps                 : 108
field                : 30 31
fields               : 27
fieldvalue           : 123 124
fieldvalues          : 113 124
function             : 48 49
functions            : 1
html                 : 2 3
htmlbody             : 6 7
htmls                : 1 3
identifiers          : 37 39 102 104
input                : 83 84
inputs               : 76
lvalue               : 85 86 107
nearguments          : 52 54
neattributes         : 16 18
neexps               : 116 118
nefields             : 29 31
nefieldvalues        : 122
nefunctions          : 47 49
nehtmlbodies         : 4 7 14
neinputs             : 82 84
neschemas            : 24 26
nestms               : 60 62
nevariables          : 34 36
plug                 : 78 79
plugs                : 74 79
receive              : 64
schema               : 25 26
schemas              : 1
service              : 0
session              : 56 57
sessions             : 1 57
simpletype           : 32 44
stm                  : 61 62
stms                 : 77
type                 : 37 50 55
variable             : 35 36
variables            : 1 77

Parsing method: LALR

state 0

    (0) S' -> . service
    (1) service -> . SERVICE { htmls schemas variables functions sessions }

    SERVICE         shift and go to state 2

    service                        shift and go to state 1

state 1

    (0) S' -> service .



state 2

    (1) service -> SERVICE . { htmls schemas variables functions sessions }

    {               shift and go to state 3


state 3

    (1) service -> SERVICE { . htmls schemas variables functions sessions }
    (2) htmls -> . html
    (3) htmls -> . html htmls
    (4) html -> . CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> . CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;

    CONST           shift and go to state 4

    htmls                          shift and go to state 6
    html                           shift and go to state 5

state 4

    (4) html -> CONST . HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST . HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;

    HTML            shift and go to state 7


state 5

    (2) htmls -> html .
    (3) htmls -> html . htmls
    (2) htmls -> . html
    (3) htmls -> . html htmls
    (4) html -> . CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> . CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;

    SCHEMA          reduce using rule 2 (htmls -> html .)
    TUPLE           reduce using rule 2 (htmls -> html .)
    INT             reduce using rule 2 (htmls -> html .)
    BOOL            reduce using rule 2 (htmls -> html .)
    STRING          reduce using rule 2 (htmls -> html .)
    VOID            reduce using rule 2 (htmls -> html .)
    SESSION         reduce using rule 2 (htmls -> html .)
    CONST           shift and go to state 4

    html                           shift and go to state 5
    htmls                          shift and go to state 8

state 6

    (1) service -> SERVICE { htmls . schemas variables functions sessions }
    (23) schemas -> .
    (24) schemas -> . neschemas
    (25) neschemas -> . schema
    (26) neschemas -> . schema neschemas
    (27) schema -> . SCHEMA IDENTIFIER { fields }

    TUPLE           reduce using rule 23 (schemas -> .)
    INT             reduce using rule 23 (schemas -> .)
    BOOL            reduce using rule 23 (schemas -> .)
    STRING          reduce using rule 23 (schemas -> .)
    VOID            reduce using rule 23 (schemas -> .)
    SESSION         reduce using rule 23 (schemas -> .)
    SCHEMA          shift and go to state 9

    neschemas                      shift and go to state 10
    schema                         shift and go to state 11
    schemas                        shift and go to state 12

state 7

    (4) html -> CONST HTML . IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST HTML . IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;

    IDENTIFIER      shift and go to state 13


state 8

    (3) htmls -> html htmls .

    SCHEMA          reduce using rule 3 (htmls -> html htmls .)
    TUPLE           reduce using rule 3 (htmls -> html htmls .)
    INT             reduce using rule 3 (htmls -> html htmls .)
    BOOL            reduce using rule 3 (htmls -> html htmls .)
    STRING          reduce using rule 3 (htmls -> html htmls .)
    VOID            reduce using rule 3 (htmls -> html htmls .)
    SESSION         reduce using rule 3 (htmls -> html htmls .)


state 9

    (27) schema -> SCHEMA . IDENTIFIER { fields }

    IDENTIFIER      shift and go to state 14


state 10

    (24) schemas -> neschemas .

    TUPLE           reduce using rule 24 (schemas -> neschemas .)
    INT             reduce using rule 24 (schemas -> neschemas .)
    BOOL            reduce using rule 24 (schemas -> neschemas .)
    STRING          reduce using rule 24 (schemas -> neschemas .)
    VOID            reduce using rule 24 (schemas -> neschemas .)
    SESSION         reduce using rule 24 (schemas -> neschemas .)


state 11

    (25) neschemas -> schema .
    (26) neschemas -> schema . neschemas
    (25) neschemas -> . schema
    (26) neschemas -> . schema neschemas
    (27) schema -> . SCHEMA IDENTIFIER { fields }

    TUPLE           reduce using rule 25 (neschemas -> schema .)
    INT             reduce using rule 25 (neschemas -> schema .)
    BOOL            reduce using rule 25 (neschemas -> schema .)
    STRING          reduce using rule 25 (neschemas -> schema .)
    VOID            reduce using rule 25 (neschemas -> schema .)
    SESSION         reduce using rule 25 (neschemas -> schema .)
    SCHEMA          shift and go to state 9

    neschemas                      shift and go to state 15
    schema                         shift and go to state 11

state 12

    (1) service -> SERVICE { htmls schemas . variables functions sessions }
    (33) variables -> .
    (34) variables -> . nevariables
    (35) nevariables -> . variable
    (36) nevariables -> . variable nevariables
    (37) variable -> . type identifiers ;
    (44) type -> . simpletype
    (45) type -> . TUPLE IDENTIFIER
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

  ! shift/reduce conflict for TUPLE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    SESSION         reduce using rule 33 (variables -> .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

  ! TUPLE           [ reduce using rule 33 (variables -> .) ]
  ! INT             [ reduce using rule 33 (variables -> .) ]
  ! BOOL            [ reduce using rule 33 (variables -> .) ]
  ! STRING          [ reduce using rule 33 (variables -> .) ]
  ! VOID            [ reduce using rule 33 (variables -> .) ]

    simpletype                     shift and go to state 16
    nevariables                    shift and go to state 17
    variables                      shift and go to state 20
    variable                       shift and go to state 25
    type                           shift and go to state 19

state 13

    (4) html -> CONST HTML IDENTIFIER . = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST HTML IDENTIFIER . = START_HTML_LITERAL END_HTML_LITERAL ;

    =               shift and go to state 26


state 14

    (27) schema -> SCHEMA IDENTIFIER . { fields }

    {               shift and go to state 27


state 15

    (26) neschemas -> schema neschemas .

    TUPLE           reduce using rule 26 (neschemas -> schema neschemas .)
    INT             reduce using rule 26 (neschemas -> schema neschemas .)
    BOOL            reduce using rule 26 (neschemas -> schema neschemas .)
    STRING          reduce using rule 26 (neschemas -> schema neschemas .)
    VOID            reduce using rule 26 (neschemas -> schema neschemas .)
    SESSION         reduce using rule 26 (neschemas -> schema neschemas .)


state 16

    (44) type -> simpletype .

    IDENTIFIER      reduce using rule 44 (type -> simpletype .)


state 17

    (34) variables -> nevariables .

    ;               reduce using rule 34 (variables -> nevariables .)
    SHOW            reduce using rule 34 (variables -> nevariables .)
    EXIT            reduce using rule 34 (variables -> nevariables .)
    RETURN          reduce using rule 34 (variables -> nevariables .)
    IF              reduce using rule 34 (variables -> nevariables .)
    WHILE           reduce using rule 34 (variables -> nevariables .)
    {               reduce using rule 34 (variables -> nevariables .)
    -               reduce using rule 34 (variables -> nevariables .)
    !               reduce using rule 34 (variables -> nevariables .)
    IDENTIFIER      reduce using rule 34 (variables -> nevariables .)
    STRING_LITERAL  reduce using rule 34 (variables -> nevariables .)
    TRUE            reduce using rule 34 (variables -> nevariables .)
    FALSE           reduce using rule 34 (variables -> nevariables .)
    INT_LITERAL     reduce using rule 34 (variables -> nevariables .)
    TUPLE           reduce using rule 34 (variables -> nevariables .)
    (               reduce using rule 34 (variables -> nevariables .)
    }               reduce using rule 34 (variables -> nevariables .)
    INT             reduce using rule 34 (variables -> nevariables .)
    BOOL            reduce using rule 34 (variables -> nevariables .)
    STRING          reduce using rule 34 (variables -> nevariables .)
    VOID            reduce using rule 34 (variables -> nevariables .)
    SESSION         reduce using rule 34 (variables -> nevariables .)


state 18

    (40) simpletype -> INT .

    IDENTIFIER      reduce using rule 40 (simpletype -> INT .)


state 19

    (37) variable -> type . identifiers ;
    (38) identifiers -> . IDENTIFIER
    (39) identifiers -> . IDENTIFIER , identifiers

    IDENTIFIER      shift and go to state 28

    identifiers                    shift and go to state 29

state 20

    (1) service -> SERVICE { htmls schemas variables . functions sessions }
    (46) functions -> .
    (47) functions -> . nefunctions
    (48) nefunctions -> . function
    (49) nefunctions -> . function nefunctions
    (50) function -> . type IDENTIFIER ( arguments ) compoundstm
    (44) type -> . simpletype
    (45) type -> . TUPLE IDENTIFIER
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

    SESSION         reduce using rule 46 (functions -> .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    function                       shift and go to state 32
    functions                      shift and go to state 30
    simpletype                     shift and go to state 16
    nefunctions                    shift and go to state 33
    type                           shift and go to state 31

state 21

    (45) type -> TUPLE . IDENTIFIER

    IDENTIFIER      shift and go to state 34


state 22

    (43) simpletype -> VOID .

    IDENTIFIER      reduce using rule 43 (simpletype -> VOID .)


state 23

    (41) simpletype -> BOOL .

    IDENTIFIER      reduce using rule 41 (simpletype -> BOOL .)


state 24

    (42) simpletype -> STRING .

    IDENTIFIER      reduce using rule 42 (simpletype -> STRING .)


state 25

    (35) nevariables -> variable .
    (36) nevariables -> variable . nevariables
    (35) nevariables -> . variable
    (36) nevariables -> . variable nevariables
    (37) variable -> . type identifiers ;
    (44) type -> . simpletype
    (45) type -> . TUPLE IDENTIFIER
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

  ! shift/reduce conflict for TUPLE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    ;               reduce using rule 35 (nevariables -> variable .)
    SHOW            reduce using rule 35 (nevariables -> variable .)
    EXIT            reduce using rule 35 (nevariables -> variable .)
    RETURN          reduce using rule 35 (nevariables -> variable .)
    IF              reduce using rule 35 (nevariables -> variable .)
    WHILE           reduce using rule 35 (nevariables -> variable .)
    {               reduce using rule 35 (nevariables -> variable .)
    -               reduce using rule 35 (nevariables -> variable .)
    !               reduce using rule 35 (nevariables -> variable .)
    IDENTIFIER      reduce using rule 35 (nevariables -> variable .)
    STRING_LITERAL  reduce using rule 35 (nevariables -> variable .)
    TRUE            reduce using rule 35 (nevariables -> variable .)
    FALSE           reduce using rule 35 (nevariables -> variable .)
    INT_LITERAL     reduce using rule 35 (nevariables -> variable .)
    (               reduce using rule 35 (nevariables -> variable .)
    }               reduce using rule 35 (nevariables -> variable .)
    SESSION         reduce using rule 35 (nevariables -> variable .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

  ! TUPLE           [ reduce using rule 35 (nevariables -> variable .) ]
  ! INT             [ reduce using rule 35 (nevariables -> variable .) ]
  ! BOOL            [ reduce using rule 35 (nevariables -> variable .) ]
  ! STRING          [ reduce using rule 35 (nevariables -> variable .) ]
  ! VOID            [ reduce using rule 35 (nevariables -> variable .) ]

    variable                       shift and go to state 25
    simpletype                     shift and go to state 16
    type                           shift and go to state 19
    nevariables                    shift and go to state 35

state 26

    (4) html -> CONST HTML IDENTIFIER = . START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST HTML IDENTIFIER = . START_HTML_LITERAL END_HTML_LITERAL ;

    START_HTML_LITERAL shift and go to state 36


state 27

    (27) schema -> SCHEMA IDENTIFIER { . fields }
    (28) fields -> .
    (29) fields -> . nefields
    (30) nefields -> . field
    (31) nefields -> . field nefields
    (32) field -> . simpletype IDENTIFIER ;
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

    }               reduce using rule 28 (fields -> .)
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    fields                         shift and go to state 38
    simpletype                     shift and go to state 40
    nefields                       shift and go to state 37
    field                          shift and go to state 39

state 28

    (38) identifiers -> IDENTIFIER .
    (39) identifiers -> IDENTIFIER . , identifiers

    )               reduce using rule 38 (identifiers -> IDENTIFIER .)
    ;               reduce using rule 38 (identifiers -> IDENTIFIER .)
    ,               shift and go to state 41


state 29

    (37) variable -> type identifiers . ;

    ;               shift and go to state 42


state 30

    (1) service -> SERVICE { htmls schemas variables functions . sessions }
    (56) sessions -> . session
    (57) sessions -> . session sessions
    (58) session -> . SESSION IDENTIFIER ( ) compoundstm

    SESSION         shift and go to state 44

    sessions                       shift and go to state 45
    session                        shift and go to state 43

state 31

    (50) function -> type . IDENTIFIER ( arguments ) compoundstm

    IDENTIFIER      shift and go to state 46


state 32

    (48) nefunctions -> function .
    (49) nefunctions -> function . nefunctions
    (48) nefunctions -> . function
    (49) nefunctions -> . function nefunctions
    (50) function -> . type IDENTIFIER ( arguments ) compoundstm
    (44) type -> . simpletype
    (45) type -> . TUPLE IDENTIFIER
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

    SESSION         reduce using rule 48 (nefunctions -> function .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    function                       shift and go to state 32
    simpletype                     shift and go to state 16
    nefunctions                    shift and go to state 47
    type                           shift and go to state 31

state 33

    (47) functions -> nefunctions .

    SESSION         reduce using rule 47 (functions -> nefunctions .)


state 34

    (45) type -> TUPLE IDENTIFIER .

    IDENTIFIER      reduce using rule 45 (type -> TUPLE IDENTIFIER .)


state 35

    (36) nevariables -> variable nevariables .

    ;               reduce using rule 36 (nevariables -> variable nevariables .)
    SHOW            reduce using rule 36 (nevariables -> variable nevariables .)
    EXIT            reduce using rule 36 (nevariables -> variable nevariables .)
    RETURN          reduce using rule 36 (nevariables -> variable nevariables .)
    IF              reduce using rule 36 (nevariables -> variable nevariables .)
    WHILE           reduce using rule 36 (nevariables -> variable nevariables .)
    {               reduce using rule 36 (nevariables -> variable nevariables .)
    -               reduce using rule 36 (nevariables -> variable nevariables .)
    !               reduce using rule 36 (nevariables -> variable nevariables .)
    IDENTIFIER      reduce using rule 36 (nevariables -> variable nevariables .)
    STRING_LITERAL  reduce using rule 36 (nevariables -> variable nevariables .)
    TRUE            reduce using rule 36 (nevariables -> variable nevariables .)
    FALSE           reduce using rule 36 (nevariables -> variable nevariables .)
    INT_LITERAL     reduce using rule 36 (nevariables -> variable nevariables .)
    TUPLE           reduce using rule 36 (nevariables -> variable nevariables .)
    (               reduce using rule 36 (nevariables -> variable nevariables .)
    }               reduce using rule 36 (nevariables -> variable nevariables .)
    INT             reduce using rule 36 (nevariables -> variable nevariables .)
    BOOL            reduce using rule 36 (nevariables -> variable nevariables .)
    STRING          reduce using rule 36 (nevariables -> variable nevariables .)
    VOID            reduce using rule 36 (nevariables -> variable nevariables .)
    SESSION         reduce using rule 36 (nevariables -> variable nevariables .)


state 36

    (4) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL . nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL . END_HTML_LITERAL ;
    (6) nehtmlbodies -> . htmlbody
    (7) nehtmlbodies -> . htmlbody nehtmlbodies
    (8) htmlbody -> . START_TAG IDENTIFIER attributes END_TAG
    (9) htmlbody -> . START_CLOSE_TAG IDENTIFIER END_TAG
    (10) htmlbody -> . START_HOLE IDENTIFIER END_HOLE
    (11) htmlbody -> . WHATEVER
    (12) htmlbody -> . META
    (13) htmlbody -> . START_TAG INPUT attributes END_TAG
    (14) htmlbody -> . START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG

    END_HTML_LITERAL shift and go to state 54
    START_TAG       shift and go to state 50
    START_CLOSE_TAG shift and go to state 49
    START_HOLE      shift and go to state 48
    WHATEVER        shift and go to state 51
    META            shift and go to state 53

    nehtmlbodies                   shift and go to state 55
    htmlbody                       shift and go to state 52

state 37

    (29) fields -> nefields .

    }               reduce using rule 29 (fields -> nefields .)


state 38

    (27) schema -> SCHEMA IDENTIFIER { fields . }

    }               shift and go to state 56


state 39

    (30) nefields -> field .
    (31) nefields -> field . nefields
    (30) nefields -> . field
    (31) nefields -> . field nefields
    (32) field -> . simpletype IDENTIFIER ;
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

    }               reduce using rule 30 (nefields -> field .)
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    field                          shift and go to state 39
    nefields                       shift and go to state 57
    simpletype                     shift and go to state 40

state 40

    (32) field -> simpletype . IDENTIFIER ;

    IDENTIFIER      shift and go to state 58


state 41

    (39) identifiers -> IDENTIFIER , . identifiers
    (38) identifiers -> . IDENTIFIER
    (39) identifiers -> . IDENTIFIER , identifiers

    IDENTIFIER      shift and go to state 28

    identifiers                    shift and go to state 59

state 42

    (37) variable -> type identifiers ; .

    TUPLE           reduce using rule 37 (variable -> type identifiers ; .)
    INT             reduce using rule 37 (variable -> type identifiers ; .)
    BOOL            reduce using rule 37 (variable -> type identifiers ; .)
    STRING          reduce using rule 37 (variable -> type identifiers ; .)
    VOID            reduce using rule 37 (variable -> type identifiers ; .)
    SESSION         reduce using rule 37 (variable -> type identifiers ; .)
    ;               reduce using rule 37 (variable -> type identifiers ; .)
    SHOW            reduce using rule 37 (variable -> type identifiers ; .)
    EXIT            reduce using rule 37 (variable -> type identifiers ; .)
    RETURN          reduce using rule 37 (variable -> type identifiers ; .)
    IF              reduce using rule 37 (variable -> type identifiers ; .)
    WHILE           reduce using rule 37 (variable -> type identifiers ; .)
    {               reduce using rule 37 (variable -> type identifiers ; .)
    -               reduce using rule 37 (variable -> type identifiers ; .)
    !               reduce using rule 37 (variable -> type identifiers ; .)
    IDENTIFIER      reduce using rule 37 (variable -> type identifiers ; .)
    STRING_LITERAL  reduce using rule 37 (variable -> type identifiers ; .)
    TRUE            reduce using rule 37 (variable -> type identifiers ; .)
    FALSE           reduce using rule 37 (variable -> type identifiers ; .)
    INT_LITERAL     reduce using rule 37 (variable -> type identifiers ; .)
    (               reduce using rule 37 (variable -> type identifiers ; .)
    }               reduce using rule 37 (variable -> type identifiers ; .)


state 43

    (56) sessions -> session .
    (57) sessions -> session . sessions
    (56) sessions -> . session
    (57) sessions -> . session sessions
    (58) session -> . SESSION IDENTIFIER ( ) compoundstm

    }               reduce using rule 56 (sessions -> session .)
    SESSION         shift and go to state 44

    session                        shift and go to state 43
    sessions                       shift and go to state 60

state 44

    (58) session -> SESSION . IDENTIFIER ( ) compoundstm

    IDENTIFIER      shift and go to state 61


state 45

    (1) service -> SERVICE { htmls schemas variables functions sessions . }

    }               shift and go to state 62


state 46

    (50) function -> type IDENTIFIER . ( arguments ) compoundstm

    (               shift and go to state 63


state 47

    (49) nefunctions -> function nefunctions .

    SESSION         reduce using rule 49 (nefunctions -> function nefunctions .)


state 48

    (10) htmlbody -> START_HOLE . IDENTIFIER END_HOLE

    IDENTIFIER      shift and go to state 64


state 49

    (9) htmlbody -> START_CLOSE_TAG . IDENTIFIER END_TAG

    IDENTIFIER      shift and go to state 65


state 50

    (8) htmlbody -> START_TAG . IDENTIFIER attributes END_TAG
    (13) htmlbody -> START_TAG . INPUT attributes END_TAG
    (14) htmlbody -> START_TAG . SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG

    IDENTIFIER      shift and go to state 67
    INPUT           shift and go to state 66
    SELECT          shift and go to state 68


state 51

    (11) htmlbody -> WHATEVER .

    START_TAG       reduce using rule 11 (htmlbody -> WHATEVER .)
    START_CLOSE_TAG reduce using rule 11 (htmlbody -> WHATEVER .)
    START_HOLE      reduce using rule 11 (htmlbody -> WHATEVER .)
    WHATEVER        reduce using rule 11 (htmlbody -> WHATEVER .)
    META            reduce using rule 11 (htmlbody -> WHATEVER .)
    END_HTML_LITERAL reduce using rule 11 (htmlbody -> WHATEVER .)


state 52

    (6) nehtmlbodies -> htmlbody .
    (7) nehtmlbodies -> htmlbody . nehtmlbodies
    (6) nehtmlbodies -> . htmlbody
    (7) nehtmlbodies -> . htmlbody nehtmlbodies
    (8) htmlbody -> . START_TAG IDENTIFIER attributes END_TAG
    (9) htmlbody -> . START_CLOSE_TAG IDENTIFIER END_TAG
    (10) htmlbody -> . START_HOLE IDENTIFIER END_HOLE
    (11) htmlbody -> . WHATEVER
    (12) htmlbody -> . META
    (13) htmlbody -> . START_TAG INPUT attributes END_TAG
    (14) htmlbody -> . START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG

  ! shift/reduce conflict for START_CLOSE_TAG resolved as shift
    END_HTML_LITERAL reduce using rule 6 (nehtmlbodies -> htmlbody .)
    START_TAG       shift and go to state 50
    START_CLOSE_TAG shift and go to state 49
    START_HOLE      shift and go to state 48
    WHATEVER        shift and go to state 51
    META            shift and go to state 53

  ! START_CLOSE_TAG [ reduce using rule 6 (nehtmlbodies -> htmlbody .) ]

    nehtmlbodies                   shift and go to state 69
    htmlbody                       shift and go to state 52

state 53

    (12) htmlbody -> META .

    START_TAG       reduce using rule 12 (htmlbody -> META .)
    START_CLOSE_TAG reduce using rule 12 (htmlbody -> META .)
    START_HOLE      reduce using rule 12 (htmlbody -> META .)
    WHATEVER        reduce using rule 12 (htmlbody -> META .)
    META            reduce using rule 12 (htmlbody -> META .)
    END_HTML_LITERAL reduce using rule 12 (htmlbody -> META .)


state 54

    (5) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL . ;

    ;               shift and go to state 70


state 55

    (4) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies . END_HTML_LITERAL ;

    END_HTML_LITERAL shift and go to state 71


state 56

    (27) schema -> SCHEMA IDENTIFIER { fields } .

    SCHEMA          reduce using rule 27 (schema -> SCHEMA IDENTIFIER { fields } .)
    TUPLE           reduce using rule 27 (schema -> SCHEMA IDENTIFIER { fields } .)
    INT             reduce using rule 27 (schema -> SCHEMA IDENTIFIER { fields } .)
    BOOL            reduce using rule 27 (schema -> SCHEMA IDENTIFIER { fields } .)
    STRING          reduce using rule 27 (schema -> SCHEMA IDENTIFIER { fields } .)
    VOID            reduce using rule 27 (schema -> SCHEMA IDENTIFIER { fields } .)
    SESSION         reduce using rule 27 (schema -> SCHEMA IDENTIFIER { fields } .)


state 57

    (31) nefields -> field nefields .

    }               reduce using rule 31 (nefields -> field nefields .)


state 58

    (32) field -> simpletype IDENTIFIER . ;

    ;               shift and go to state 72


state 59

    (39) identifiers -> IDENTIFIER , identifiers .

    )               reduce using rule 39 (identifiers -> IDENTIFIER , identifiers .)
    ;               reduce using rule 39 (identifiers -> IDENTIFIER , identifiers .)


state 60

    (57) sessions -> session sessions .

    }               reduce using rule 57 (sessions -> session sessions .)


state 61

    (58) session -> SESSION IDENTIFIER . ( ) compoundstm

    (               shift and go to state 73


state 62

    (1) service -> SERVICE { htmls schemas variables functions sessions } .

    $end            reduce using rule 1 (service -> SERVICE { htmls schemas variables functions sessions } .)


state 63

    (50) function -> type IDENTIFIER ( . arguments ) compoundstm
    (51) arguments -> .
    (52) arguments -> . nearguments
    (53) nearguments -> . argument
    (54) nearguments -> . argument , nearguments
    (55) argument -> . type IDENTIFIER
    (44) type -> . simpletype
    (45) type -> . TUPLE IDENTIFIER
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

    )               reduce using rule 51 (arguments -> .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    simpletype                     shift and go to state 16
    nearguments                    shift and go to state 74
    type                           shift and go to state 77
    argument                       shift and go to state 75
    arguments                      shift and go to state 76

state 64

    (10) htmlbody -> START_HOLE IDENTIFIER . END_HOLE

    END_HOLE        shift and go to state 78


state 65

    (9) htmlbody -> START_CLOSE_TAG IDENTIFIER . END_TAG

    END_TAG         shift and go to state 79


state 66

    (13) htmlbody -> START_TAG INPUT . attributes END_TAG
    (15) attributes -> .
    (16) attributes -> . neattributes
    (17) neattributes -> . attribute
    (18) neattributes -> . attribute neattributes
    (19) attribute -> . attr
    (20) attribute -> . attr = attr
    (21) attr -> . IDENTIFIER
    (22) attr -> . STRING_LITERAL

    END_TAG         reduce using rule 15 (attributes -> .)
    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    neattributes                   shift and go to state 83
    attributes                     shift and go to state 82
    attr                           shift and go to state 80
    attribute                      shift and go to state 81

state 67

    (8) htmlbody -> START_TAG IDENTIFIER . attributes END_TAG
    (15) attributes -> .
    (16) attributes -> . neattributes
    (17) neattributes -> . attribute
    (18) neattributes -> . attribute neattributes
    (19) attribute -> . attr
    (20) attribute -> . attr = attr
    (21) attr -> . IDENTIFIER
    (22) attr -> . STRING_LITERAL

    END_TAG         reduce using rule 15 (attributes -> .)
    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    neattributes                   shift and go to state 83
    attributes                     shift and go to state 86
    attr                           shift and go to state 80
    attribute                      shift and go to state 81

state 68

    (14) htmlbody -> START_TAG SELECT . attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (15) attributes -> .
    (16) attributes -> . neattributes
    (17) neattributes -> . attribute
    (18) neattributes -> . attribute neattributes
    (19) attribute -> . attr
    (20) attribute -> . attr = attr
    (21) attr -> . IDENTIFIER
    (22) attr -> . STRING_LITERAL

    END_TAG         reduce using rule 15 (attributes -> .)
    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    neattributes                   shift and go to state 83
    attributes                     shift and go to state 87
    attr                           shift and go to state 80
    attribute                      shift and go to state 81

state 69

    (7) nehtmlbodies -> htmlbody nehtmlbodies .

    END_HTML_LITERAL reduce using rule 7 (nehtmlbodies -> htmlbody nehtmlbodies .)
    START_CLOSE_TAG reduce using rule 7 (nehtmlbodies -> htmlbody nehtmlbodies .)


state 70

    (5) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .

    CONST           reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    SCHEMA          reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    TUPLE           reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    INT             reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    BOOL            reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    STRING          reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    VOID            reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    SESSION         reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)


state 71

    (4) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL . ;

    ;               shift and go to state 88


state 72

    (32) field -> simpletype IDENTIFIER ; .

    INT             reduce using rule 32 (field -> simpletype IDENTIFIER ; .)
    BOOL            reduce using rule 32 (field -> simpletype IDENTIFIER ; .)
    STRING          reduce using rule 32 (field -> simpletype IDENTIFIER ; .)
    VOID            reduce using rule 32 (field -> simpletype IDENTIFIER ; .)
    }               reduce using rule 32 (field -> simpletype IDENTIFIER ; .)


state 73

    (58) session -> SESSION IDENTIFIER ( . ) compoundstm

    )               shift and go to state 89


state 74

    (52) arguments -> nearguments .

    )               reduce using rule 52 (arguments -> nearguments .)


state 75

    (53) nearguments -> argument .
    (54) nearguments -> argument . , nearguments

    )               reduce using rule 53 (nearguments -> argument .)
    ,               shift and go to state 90


state 76

    (50) function -> type IDENTIFIER ( arguments . ) compoundstm

    )               shift and go to state 91


state 77

    (55) argument -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 92


state 78

    (10) htmlbody -> START_HOLE IDENTIFIER END_HOLE .

    START_TAG       reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    START_CLOSE_TAG reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    START_HOLE      reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    WHATEVER        reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    META            reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    END_HTML_LITERAL reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)


state 79

    (9) htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .

    START_TAG       reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    START_CLOSE_TAG reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    START_HOLE      reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    WHATEVER        reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    META            reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    END_HTML_LITERAL reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)


state 80

    (19) attribute -> attr .
    (20) attribute -> attr . = attr

    IDENTIFIER      reduce using rule 19 (attribute -> attr .)
    STRING_LITERAL  reduce using rule 19 (attribute -> attr .)
    END_TAG         reduce using rule 19 (attribute -> attr .)
    =               shift and go to state 93


state 81

    (17) neattributes -> attribute .
    (18) neattributes -> attribute . neattributes
    (17) neattributes -> . attribute
    (18) neattributes -> . attribute neattributes
    (19) attribute -> . attr
    (20) attribute -> . attr = attr
    (21) attr -> . IDENTIFIER
    (22) attr -> . STRING_LITERAL

    END_TAG         reduce using rule 17 (neattributes -> attribute .)
    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    neattributes                   shift and go to state 94
    attribute                      shift and go to state 81
    attr                           shift and go to state 80

state 82

    (13) htmlbody -> START_TAG INPUT attributes . END_TAG

    END_TAG         shift and go to state 95


state 83

    (16) attributes -> neattributes .

    END_TAG         reduce using rule 16 (attributes -> neattributes .)


state 84

    (21) attr -> IDENTIFIER .

    =               reduce using rule 21 (attr -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 21 (attr -> IDENTIFIER .)
    STRING_LITERAL  reduce using rule 21 (attr -> IDENTIFIER .)
    END_TAG         reduce using rule 21 (attr -> IDENTIFIER .)


state 85

    (22) attr -> STRING_LITERAL .

    =               reduce using rule 22 (attr -> STRING_LITERAL .)
    IDENTIFIER      reduce using rule 22 (attr -> STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 22 (attr -> STRING_LITERAL .)
    END_TAG         reduce using rule 22 (attr -> STRING_LITERAL .)


state 86

    (8) htmlbody -> START_TAG IDENTIFIER attributes . END_TAG

    END_TAG         shift and go to state 96


state 87

    (14) htmlbody -> START_TAG SELECT attributes . END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG

    END_TAG         shift and go to state 97


state 88

    (4) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .

    CONST           reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    SCHEMA          reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    TUPLE           reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    INT             reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    BOOL            reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    STRING          reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    VOID            reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    SESSION         reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)


state 89

    (58) session -> SESSION IDENTIFIER ( ) . compoundstm
    (77) compoundstm -> . { variables stms }

    {               shift and go to state 98

    compoundstm                    shift and go to state 99

state 90

    (54) nearguments -> argument , . nearguments
    (53) nearguments -> . argument
    (54) nearguments -> . argument , nearguments
    (55) argument -> . type IDENTIFIER
    (44) type -> . simpletype
    (45) type -> . TUPLE IDENTIFIER
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    simpletype                     shift and go to state 16
    type                           shift and go to state 77
    argument                       shift and go to state 75
    nearguments                    shift and go to state 100

state 91

    (50) function -> type IDENTIFIER ( arguments ) . compoundstm
    (77) compoundstm -> . { variables stms }

    {               shift and go to state 98

    compoundstm                    shift and go to state 101

state 92

    (55) argument -> type IDENTIFIER .

    ,               reduce using rule 55 (argument -> type IDENTIFIER .)
    )               reduce using rule 55 (argument -> type IDENTIFIER .)


state 93

    (20) attribute -> attr = . attr
    (21) attr -> . IDENTIFIER
    (22) attr -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    attr                           shift and go to state 102

state 94

    (18) neattributes -> attribute neattributes .

    END_TAG         reduce using rule 18 (neattributes -> attribute neattributes .)


state 95

    (13) htmlbody -> START_TAG INPUT attributes END_TAG .

    START_TAG       reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    START_CLOSE_TAG reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    START_HOLE      reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    WHATEVER        reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    META            reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    END_HTML_LITERAL reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)


state 96

    (8) htmlbody -> START_TAG IDENTIFIER attributes END_TAG .

    START_TAG       reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    START_CLOSE_TAG reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    START_HOLE      reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    WHATEVER        reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    META            reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    END_HTML_LITERAL reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)


state 97

    (14) htmlbody -> START_TAG SELECT attributes END_TAG . nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (6) nehtmlbodies -> . htmlbody
    (7) nehtmlbodies -> . htmlbody nehtmlbodies
    (8) htmlbody -> . START_TAG IDENTIFIER attributes END_TAG
    (9) htmlbody -> . START_CLOSE_TAG IDENTIFIER END_TAG
    (10) htmlbody -> . START_HOLE IDENTIFIER END_HOLE
    (11) htmlbody -> . WHATEVER
    (12) htmlbody -> . META
    (13) htmlbody -> . START_TAG INPUT attributes END_TAG
    (14) htmlbody -> . START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG

    START_TAG       shift and go to state 50
    START_CLOSE_TAG shift and go to state 49
    START_HOLE      shift and go to state 48
    WHATEVER        shift and go to state 51
    META            shift and go to state 53

    nehtmlbodies                   shift and go to state 103
    htmlbody                       shift and go to state 52

state 98

    (77) compoundstm -> { . variables stms }
    (33) variables -> .
    (34) variables -> . nevariables
    (35) nevariables -> . variable
    (36) nevariables -> . variable nevariables
    (37) variable -> . type identifiers ;
    (44) type -> . simpletype
    (45) type -> . TUPLE IDENTIFIER
    (40) simpletype -> . INT
    (41) simpletype -> . BOOL
    (42) simpletype -> . STRING
    (43) simpletype -> . VOID

  ! shift/reduce conflict for TUPLE resolved as shift
    ;               reduce using rule 33 (variables -> .)
    SHOW            reduce using rule 33 (variables -> .)
    EXIT            reduce using rule 33 (variables -> .)
    RETURN          reduce using rule 33 (variables -> .)
    IF              reduce using rule 33 (variables -> .)
    WHILE           reduce using rule 33 (variables -> .)
    {               reduce using rule 33 (variables -> .)
    -               reduce using rule 33 (variables -> .)
    !               reduce using rule 33 (variables -> .)
    IDENTIFIER      reduce using rule 33 (variables -> .)
    STRING_LITERAL  reduce using rule 33 (variables -> .)
    TRUE            reduce using rule 33 (variables -> .)
    FALSE           reduce using rule 33 (variables -> .)
    INT_LITERAL     reduce using rule 33 (variables -> .)
    (               reduce using rule 33 (variables -> .)
    }               reduce using rule 33 (variables -> .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

  ! TUPLE           [ reduce using rule 33 (variables -> .) ]

    simpletype                     shift and go to state 16
    nevariables                    shift and go to state 17
    variables                      shift and go to state 104
    variable                       shift and go to state 25
    type                           shift and go to state 19

state 99

    (58) session -> SESSION IDENTIFIER ( ) compoundstm .

    SESSION         reduce using rule 58 (session -> SESSION IDENTIFIER ( ) compoundstm .)
    }               reduce using rule 58 (session -> SESSION IDENTIFIER ( ) compoundstm .)


state 100

    (54) nearguments -> argument , nearguments .

    )               reduce using rule 54 (nearguments -> argument , nearguments .)


state 101

    (50) function -> type IDENTIFIER ( arguments ) compoundstm .

    TUPLE           reduce using rule 50 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    INT             reduce using rule 50 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    BOOL            reduce using rule 50 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    STRING          reduce using rule 50 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    VOID            reduce using rule 50 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    SESSION         reduce using rule 50 (function -> type IDENTIFIER ( arguments ) compoundstm .)


state 102

    (20) attribute -> attr = attr .

    IDENTIFIER      reduce using rule 20 (attribute -> attr = attr .)
    STRING_LITERAL  reduce using rule 20 (attribute -> attr = attr .)
    END_TAG         reduce using rule 20 (attribute -> attr = attr .)


state 103

    (14) htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies . START_CLOSE_TAG SELECT END_TAG

    START_CLOSE_TAG shift and go to state 105


state 104

    (77) compoundstm -> { variables . stms }
    (59) stms -> .
    (60) stms -> . nestms
    (61) nestms -> . stm
    (62) nestms -> . stm nestms
    (63) stm -> . ;
    (64) stm -> . SHOW document receive ;
    (65) stm -> . EXIT document ;
    (66) stm -> . RETURN ;
    (67) stm -> . RETURN exp ;
    (68) stm -> . IF ( exp ) compoundstm
    (69) stm -> . IF ( exp ) compoundstm ELSE compoundstm
    (70) stm -> . WHILE ( exp ) compoundstm
    (71) stm -> . compoundstm
    (72) stm -> . exp ;
    (77) compoundstm -> . { variables stms }
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    }               reduce using rule 59 (stms -> .)
    ;               shift and go to state 112
    SHOW            shift and go to state 114
    EXIT            shift and go to state 123
    RETURN          shift and go to state 106
    IF              shift and go to state 117
    WHILE           shift and go to state 107
    {               shift and go to state 98
    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    nestms                         shift and go to state 109
    lvalue                         shift and go to state 110
    stms                           shift and go to state 115
    exp                            shift and go to state 124
    stm                            shift and go to state 122
    compoundstm                    shift and go to state 108

state 105

    (14) htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG . SELECT END_TAG

    SELECT          shift and go to state 127


state 106

    (66) stm -> RETURN . ;
    (67) stm -> RETURN . exp ;
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    ;               shift and go to state 128
    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 129

state 107

    (70) stm -> WHILE . ( exp ) compoundstm

    (               shift and go to state 130


state 108

    (71) stm -> compoundstm .

    ;               reduce using rule 71 (stm -> compoundstm .)
    SHOW            reduce using rule 71 (stm -> compoundstm .)
    EXIT            reduce using rule 71 (stm -> compoundstm .)
    RETURN          reduce using rule 71 (stm -> compoundstm .)
    IF              reduce using rule 71 (stm -> compoundstm .)
    WHILE           reduce using rule 71 (stm -> compoundstm .)
    {               reduce using rule 71 (stm -> compoundstm .)
    -               reduce using rule 71 (stm -> compoundstm .)
    !               reduce using rule 71 (stm -> compoundstm .)
    IDENTIFIER      reduce using rule 71 (stm -> compoundstm .)
    STRING_LITERAL  reduce using rule 71 (stm -> compoundstm .)
    TRUE            reduce using rule 71 (stm -> compoundstm .)
    FALSE           reduce using rule 71 (stm -> compoundstm .)
    INT_LITERAL     reduce using rule 71 (stm -> compoundstm .)
    TUPLE           reduce using rule 71 (stm -> compoundstm .)
    (               reduce using rule 71 (stm -> compoundstm .)
    }               reduce using rule 71 (stm -> compoundstm .)


state 109

    (60) stms -> nestms .

    }               reduce using rule 60 (stms -> nestms .)


state 110

    (86) exp -> lvalue . = exp
    (107) exp -> lvalue .

    =               shift and go to state 131
    EQ              reduce using rule 107 (exp -> lvalue .)
    NEQ             reduce using rule 107 (exp -> lvalue .)
    <               reduce using rule 107 (exp -> lvalue .)
    >               reduce using rule 107 (exp -> lvalue .)
    LTEQ            reduce using rule 107 (exp -> lvalue .)
    GTEQ            reduce using rule 107 (exp -> lvalue .)
    +               reduce using rule 107 (exp -> lvalue .)
    -               reduce using rule 107 (exp -> lvalue .)
    *               reduce using rule 107 (exp -> lvalue .)
    /               reduce using rule 107 (exp -> lvalue .)
    %               reduce using rule 107 (exp -> lvalue .)
    AND             reduce using rule 107 (exp -> lvalue .)
    OR              reduce using rule 107 (exp -> lvalue .)
    LSHIFT          reduce using rule 107 (exp -> lvalue .)
    TADD            reduce using rule 107 (exp -> lvalue .)
    TSUB            reduce using rule 107 (exp -> lvalue .)
    ;               reduce using rule 107 (exp -> lvalue .)
    )               reduce using rule 107 (exp -> lvalue .)
    ,               reduce using rule 107 (exp -> lvalue .)
    }               reduce using rule 107 (exp -> lvalue .)
    ]               reduce using rule 107 (exp -> lvalue .)


state 111

    (105) exp -> - . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 132

state 112

    (63) stm -> ; .

    ;               reduce using rule 63 (stm -> ; .)
    SHOW            reduce using rule 63 (stm -> ; .)
    EXIT            reduce using rule 63 (stm -> ; .)
    RETURN          reduce using rule 63 (stm -> ; .)
    IF              reduce using rule 63 (stm -> ; .)
    WHILE           reduce using rule 63 (stm -> ; .)
    {               reduce using rule 63 (stm -> ; .)
    -               reduce using rule 63 (stm -> ; .)
    !               reduce using rule 63 (stm -> ; .)
    IDENTIFIER      reduce using rule 63 (stm -> ; .)
    STRING_LITERAL  reduce using rule 63 (stm -> ; .)
    TRUE            reduce using rule 63 (stm -> ; .)
    FALSE           reduce using rule 63 (stm -> ; .)
    INT_LITERAL     reduce using rule 63 (stm -> ; .)
    TUPLE           reduce using rule 63 (stm -> ; .)
    (               reduce using rule 63 (stm -> ; .)
    }               reduce using rule 63 (stm -> ; .)


state 113

    (106) exp -> ! . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 133

state 114

    (64) stm -> SHOW . document receive ;
    (73) document -> . IDENTIFIER
    (74) document -> . PLUG IDENTIFIER [ plugs ]

    IDENTIFIER      shift and go to state 136
    PLUG            shift and go to state 134

    document                       shift and go to state 135

state 115

    (77) compoundstm -> { variables stms . }

    }               shift and go to state 137


state 116

    (110) exp -> TRUE .

    EQ              reduce using rule 110 (exp -> TRUE .)
    NEQ             reduce using rule 110 (exp -> TRUE .)
    <               reduce using rule 110 (exp -> TRUE .)
    >               reduce using rule 110 (exp -> TRUE .)
    LTEQ            reduce using rule 110 (exp -> TRUE .)
    GTEQ            reduce using rule 110 (exp -> TRUE .)
    +               reduce using rule 110 (exp -> TRUE .)
    -               reduce using rule 110 (exp -> TRUE .)
    *               reduce using rule 110 (exp -> TRUE .)
    /               reduce using rule 110 (exp -> TRUE .)
    %               reduce using rule 110 (exp -> TRUE .)
    AND             reduce using rule 110 (exp -> TRUE .)
    OR              reduce using rule 110 (exp -> TRUE .)
    LSHIFT          reduce using rule 110 (exp -> TRUE .)
    TADD            reduce using rule 110 (exp -> TRUE .)
    TSUB            reduce using rule 110 (exp -> TRUE .)
    ;               reduce using rule 110 (exp -> TRUE .)
    )               reduce using rule 110 (exp -> TRUE .)
    ,               reduce using rule 110 (exp -> TRUE .)
    }               reduce using rule 110 (exp -> TRUE .)
    ]               reduce using rule 110 (exp -> TRUE .)


state 117

    (68) stm -> IF . ( exp ) compoundstm
    (69) stm -> IF . ( exp ) compoundstm ELSE compoundstm

    (               shift and go to state 138


state 118

    (108) exp -> IDENTIFIER . ( exps )
    (119) lvalue -> IDENTIFIER .
    (120) lvalue -> IDENTIFIER . . IDENTIFIER

    (               shift and go to state 139
    =               reduce using rule 119 (lvalue -> IDENTIFIER .)
    )               reduce using rule 119 (lvalue -> IDENTIFIER .)
    EQ              reduce using rule 119 (lvalue -> IDENTIFIER .)
    NEQ             reduce using rule 119 (lvalue -> IDENTIFIER .)
    <               reduce using rule 119 (lvalue -> IDENTIFIER .)
    >               reduce using rule 119 (lvalue -> IDENTIFIER .)
    LTEQ            reduce using rule 119 (lvalue -> IDENTIFIER .)
    GTEQ            reduce using rule 119 (lvalue -> IDENTIFIER .)
    +               reduce using rule 119 (lvalue -> IDENTIFIER .)
    -               reduce using rule 119 (lvalue -> IDENTIFIER .)
    *               reduce using rule 119 (lvalue -> IDENTIFIER .)
    /               reduce using rule 119 (lvalue -> IDENTIFIER .)
    %               reduce using rule 119 (lvalue -> IDENTIFIER .)
    AND             reduce using rule 119 (lvalue -> IDENTIFIER .)
    OR              reduce using rule 119 (lvalue -> IDENTIFIER .)
    LSHIFT          reduce using rule 119 (lvalue -> IDENTIFIER .)
    TADD            reduce using rule 119 (lvalue -> IDENTIFIER .)
    TSUB            reduce using rule 119 (lvalue -> IDENTIFIER .)
    ;               reduce using rule 119 (lvalue -> IDENTIFIER .)
    ,               reduce using rule 119 (lvalue -> IDENTIFIER .)
    }               reduce using rule 119 (lvalue -> IDENTIFIER .)
    ]               reduce using rule 119 (lvalue -> IDENTIFIER .)
    .               shift and go to state 140


state 119

    (111) exp -> FALSE .

    EQ              reduce using rule 111 (exp -> FALSE .)
    NEQ             reduce using rule 111 (exp -> FALSE .)
    <               reduce using rule 111 (exp -> FALSE .)
    >               reduce using rule 111 (exp -> FALSE .)
    LTEQ            reduce using rule 111 (exp -> FALSE .)
    GTEQ            reduce using rule 111 (exp -> FALSE .)
    +               reduce using rule 111 (exp -> FALSE .)
    -               reduce using rule 111 (exp -> FALSE .)
    *               reduce using rule 111 (exp -> FALSE .)
    /               reduce using rule 111 (exp -> FALSE .)
    %               reduce using rule 111 (exp -> FALSE .)
    AND             reduce using rule 111 (exp -> FALSE .)
    OR              reduce using rule 111 (exp -> FALSE .)
    LSHIFT          reduce using rule 111 (exp -> FALSE .)
    TADD            reduce using rule 111 (exp -> FALSE .)
    TSUB            reduce using rule 111 (exp -> FALSE .)
    ;               reduce using rule 111 (exp -> FALSE .)
    )               reduce using rule 111 (exp -> FALSE .)
    ,               reduce using rule 111 (exp -> FALSE .)
    }               reduce using rule 111 (exp -> FALSE .)
    ]               reduce using rule 111 (exp -> FALSE .)


state 120

    (109) exp -> STRING_LITERAL .

    EQ              reduce using rule 109 (exp -> STRING_LITERAL .)
    NEQ             reduce using rule 109 (exp -> STRING_LITERAL .)
    <               reduce using rule 109 (exp -> STRING_LITERAL .)
    >               reduce using rule 109 (exp -> STRING_LITERAL .)
    LTEQ            reduce using rule 109 (exp -> STRING_LITERAL .)
    GTEQ            reduce using rule 109 (exp -> STRING_LITERAL .)
    +               reduce using rule 109 (exp -> STRING_LITERAL .)
    -               reduce using rule 109 (exp -> STRING_LITERAL .)
    *               reduce using rule 109 (exp -> STRING_LITERAL .)
    /               reduce using rule 109 (exp -> STRING_LITERAL .)
    %               reduce using rule 109 (exp -> STRING_LITERAL .)
    AND             reduce using rule 109 (exp -> STRING_LITERAL .)
    OR              reduce using rule 109 (exp -> STRING_LITERAL .)
    LSHIFT          reduce using rule 109 (exp -> STRING_LITERAL .)
    TADD            reduce using rule 109 (exp -> STRING_LITERAL .)
    TSUB            reduce using rule 109 (exp -> STRING_LITERAL .)
    ;               reduce using rule 109 (exp -> STRING_LITERAL .)
    )               reduce using rule 109 (exp -> STRING_LITERAL .)
    ,               reduce using rule 109 (exp -> STRING_LITERAL .)
    }               reduce using rule 109 (exp -> STRING_LITERAL .)
    ]               reduce using rule 109 (exp -> STRING_LITERAL .)


state 121

    (113) exp -> TUPLE . { fieldvalues }

    {               shift and go to state 141


state 122

    (61) nestms -> stm .
    (62) nestms -> stm . nestms
    (61) nestms -> . stm
    (62) nestms -> . stm nestms
    (63) stm -> . ;
    (64) stm -> . SHOW document receive ;
    (65) stm -> . EXIT document ;
    (66) stm -> . RETURN ;
    (67) stm -> . RETURN exp ;
    (68) stm -> . IF ( exp ) compoundstm
    (69) stm -> . IF ( exp ) compoundstm ELSE compoundstm
    (70) stm -> . WHILE ( exp ) compoundstm
    (71) stm -> . compoundstm
    (72) stm -> . exp ;
    (77) compoundstm -> . { variables stms }
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    }               reduce using rule 61 (nestms -> stm .)
    ;               shift and go to state 112
    SHOW            shift and go to state 114
    EXIT            shift and go to state 123
    RETURN          shift and go to state 106
    IF              shift and go to state 117
    WHILE           shift and go to state 107
    {               shift and go to state 98
    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    nestms                         shift and go to state 142
    lvalue                         shift and go to state 110
    stm                            shift and go to state 122
    exp                            shift and go to state 124
    compoundstm                    shift and go to state 108

state 123

    (65) stm -> EXIT . document ;
    (73) document -> . IDENTIFIER
    (74) document -> . PLUG IDENTIFIER [ plugs ]

    IDENTIFIER      shift and go to state 136
    PLUG            shift and go to state 134

    document                       shift and go to state 143

state 124

    (72) stm -> exp . ;
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    ;               shift and go to state 154
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160
    LSHIFT          shift and go to state 146
    TADD            shift and go to state 147
    TSUB            shift and go to state 145


state 125

    (114) exp -> ( . exp )
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 161

state 126

    (112) exp -> INT_LITERAL .

    EQ              reduce using rule 112 (exp -> INT_LITERAL .)
    NEQ             reduce using rule 112 (exp -> INT_LITERAL .)
    <               reduce using rule 112 (exp -> INT_LITERAL .)
    >               reduce using rule 112 (exp -> INT_LITERAL .)
    LTEQ            reduce using rule 112 (exp -> INT_LITERAL .)
    GTEQ            reduce using rule 112 (exp -> INT_LITERAL .)
    +               reduce using rule 112 (exp -> INT_LITERAL .)
    -               reduce using rule 112 (exp -> INT_LITERAL .)
    *               reduce using rule 112 (exp -> INT_LITERAL .)
    /               reduce using rule 112 (exp -> INT_LITERAL .)
    %               reduce using rule 112 (exp -> INT_LITERAL .)
    AND             reduce using rule 112 (exp -> INT_LITERAL .)
    OR              reduce using rule 112 (exp -> INT_LITERAL .)
    LSHIFT          reduce using rule 112 (exp -> INT_LITERAL .)
    TADD            reduce using rule 112 (exp -> INT_LITERAL .)
    TSUB            reduce using rule 112 (exp -> INT_LITERAL .)
    ;               reduce using rule 112 (exp -> INT_LITERAL .)
    )               reduce using rule 112 (exp -> INT_LITERAL .)
    ,               reduce using rule 112 (exp -> INT_LITERAL .)
    }               reduce using rule 112 (exp -> INT_LITERAL .)
    ]               reduce using rule 112 (exp -> INT_LITERAL .)


state 127

    (14) htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT . END_TAG

    END_TAG         shift and go to state 162


state 128

    (66) stm -> RETURN ; .

    ;               reduce using rule 66 (stm -> RETURN ; .)
    SHOW            reduce using rule 66 (stm -> RETURN ; .)
    EXIT            reduce using rule 66 (stm -> RETURN ; .)
    RETURN          reduce using rule 66 (stm -> RETURN ; .)
    IF              reduce using rule 66 (stm -> RETURN ; .)
    WHILE           reduce using rule 66 (stm -> RETURN ; .)
    {               reduce using rule 66 (stm -> RETURN ; .)
    -               reduce using rule 66 (stm -> RETURN ; .)
    !               reduce using rule 66 (stm -> RETURN ; .)
    IDENTIFIER      reduce using rule 66 (stm -> RETURN ; .)
    STRING_LITERAL  reduce using rule 66 (stm -> RETURN ; .)
    TRUE            reduce using rule 66 (stm -> RETURN ; .)
    FALSE           reduce using rule 66 (stm -> RETURN ; .)
    INT_LITERAL     reduce using rule 66 (stm -> RETURN ; .)
    TUPLE           reduce using rule 66 (stm -> RETURN ; .)
    (               reduce using rule 66 (stm -> RETURN ; .)
    }               reduce using rule 66 (stm -> RETURN ; .)


state 129

    (67) stm -> RETURN exp . ;
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    ;               shift and go to state 163
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160
    LSHIFT          shift and go to state 146
    TADD            shift and go to state 147
    TSUB            shift and go to state 145


state 130

    (70) stm -> WHILE ( . exp ) compoundstm
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 164

state 131

    (86) exp -> lvalue = . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 165

state 132

    (105) exp -> - exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 105 (exp -> - exp .)
    NEQ             reduce using rule 105 (exp -> - exp .)
    <               reduce using rule 105 (exp -> - exp .)
    >               reduce using rule 105 (exp -> - exp .)
    LTEQ            reduce using rule 105 (exp -> - exp .)
    GTEQ            reduce using rule 105 (exp -> - exp .)
    +               reduce using rule 105 (exp -> - exp .)
    -               reduce using rule 105 (exp -> - exp .)
    *               reduce using rule 105 (exp -> - exp .)
    /               reduce using rule 105 (exp -> - exp .)
    %               reduce using rule 105 (exp -> - exp .)
    AND             reduce using rule 105 (exp -> - exp .)
    OR              reduce using rule 105 (exp -> - exp .)
    LSHIFT          reduce using rule 105 (exp -> - exp .)
    TADD            reduce using rule 105 (exp -> - exp .)
    TSUB            reduce using rule 105 (exp -> - exp .)
    ;               reduce using rule 105 (exp -> - exp .)
    )               reduce using rule 105 (exp -> - exp .)
    ,               reduce using rule 105 (exp -> - exp .)
    }               reduce using rule 105 (exp -> - exp .)
    ]               reduce using rule 105 (exp -> - exp .)

  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! +               [ shift and go to state 150 ]
  ! -               [ shift and go to state 152 ]
  ! *               [ shift and go to state 151 ]
  ! /               [ shift and go to state 153 ]
  ! %               [ shift and go to state 149 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 133

    (106) exp -> ! exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 106 (exp -> ! exp .)
    NEQ             reduce using rule 106 (exp -> ! exp .)
    <               reduce using rule 106 (exp -> ! exp .)
    >               reduce using rule 106 (exp -> ! exp .)
    LTEQ            reduce using rule 106 (exp -> ! exp .)
    GTEQ            reduce using rule 106 (exp -> ! exp .)
    +               reduce using rule 106 (exp -> ! exp .)
    -               reduce using rule 106 (exp -> ! exp .)
    *               reduce using rule 106 (exp -> ! exp .)
    /               reduce using rule 106 (exp -> ! exp .)
    %               reduce using rule 106 (exp -> ! exp .)
    AND             reduce using rule 106 (exp -> ! exp .)
    OR              reduce using rule 106 (exp -> ! exp .)
    LSHIFT          reduce using rule 106 (exp -> ! exp .)
    TADD            reduce using rule 106 (exp -> ! exp .)
    TSUB            reduce using rule 106 (exp -> ! exp .)
    ;               reduce using rule 106 (exp -> ! exp .)
    )               reduce using rule 106 (exp -> ! exp .)
    ,               reduce using rule 106 (exp -> ! exp .)
    }               reduce using rule 106 (exp -> ! exp .)
    ]               reduce using rule 106 (exp -> ! exp .)

  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! +               [ shift and go to state 150 ]
  ! -               [ shift and go to state 152 ]
  ! *               [ shift and go to state 151 ]
  ! /               [ shift and go to state 153 ]
  ! %               [ shift and go to state 149 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 134

    (74) document -> PLUG . IDENTIFIER [ plugs ]

    IDENTIFIER      shift and go to state 166


state 135

    (64) stm -> SHOW document . receive ;
    (75) receive -> .
    (76) receive -> . RECEIVE [ inputs ]

    ;               reduce using rule 75 (receive -> .)
    RECEIVE         shift and go to state 168

    receive                        shift and go to state 167

state 136

    (73) document -> IDENTIFIER .

    RECEIVE         reduce using rule 73 (document -> IDENTIFIER .)
    ;               reduce using rule 73 (document -> IDENTIFIER .)


state 137

    (77) compoundstm -> { variables stms } .

    ;               reduce using rule 77 (compoundstm -> { variables stms } .)
    SHOW            reduce using rule 77 (compoundstm -> { variables stms } .)
    EXIT            reduce using rule 77 (compoundstm -> { variables stms } .)
    RETURN          reduce using rule 77 (compoundstm -> { variables stms } .)
    IF              reduce using rule 77 (compoundstm -> { variables stms } .)
    WHILE           reduce using rule 77 (compoundstm -> { variables stms } .)
    {               reduce using rule 77 (compoundstm -> { variables stms } .)
    -               reduce using rule 77 (compoundstm -> { variables stms } .)
    !               reduce using rule 77 (compoundstm -> { variables stms } .)
    IDENTIFIER      reduce using rule 77 (compoundstm -> { variables stms } .)
    STRING_LITERAL  reduce using rule 77 (compoundstm -> { variables stms } .)
    TRUE            reduce using rule 77 (compoundstm -> { variables stms } .)
    FALSE           reduce using rule 77 (compoundstm -> { variables stms } .)
    INT_LITERAL     reduce using rule 77 (compoundstm -> { variables stms } .)
    TUPLE           reduce using rule 77 (compoundstm -> { variables stms } .)
    (               reduce using rule 77 (compoundstm -> { variables stms } .)
    }               reduce using rule 77 (compoundstm -> { variables stms } .)
    ELSE            reduce using rule 77 (compoundstm -> { variables stms } .)
    SESSION         reduce using rule 77 (compoundstm -> { variables stms } .)
    INT             reduce using rule 77 (compoundstm -> { variables stms } .)
    BOOL            reduce using rule 77 (compoundstm -> { variables stms } .)
    STRING          reduce using rule 77 (compoundstm -> { variables stms } .)
    VOID            reduce using rule 77 (compoundstm -> { variables stms } .)


state 138

    (68) stm -> IF ( . exp ) compoundstm
    (69) stm -> IF ( . exp ) compoundstm ELSE compoundstm
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 169

state 139

    (108) exp -> IDENTIFIER ( . exps )
    (115) exps -> .
    (116) exps -> . neexps
    (117) neexps -> . exp
    (118) neexps -> . exp , neexps
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    )               reduce using rule 115 (exps -> .)
    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    neexps                         shift and go to state 170
    exps                           shift and go to state 171
    lvalue                         shift and go to state 110
    exp                            shift and go to state 172

state 140

    (120) lvalue -> IDENTIFIER . . IDENTIFIER

    IDENTIFIER      shift and go to state 173


state 141

    (113) exp -> TUPLE { . fieldvalues }
    (121) fieldvalues -> .
    (122) fieldvalues -> . nefieldvalues
    (123) nefieldvalues -> . fieldvalue
    (124) nefieldvalues -> . fieldvalue , fieldvalues
    (125) fieldvalue -> . IDENTIFIER = exp

    }               reduce using rule 121 (fieldvalues -> .)
    IDENTIFIER      shift and go to state 176

    nefieldvalues                  shift and go to state 174
    fieldvalues                    shift and go to state 175
    fieldvalue                     shift and go to state 177

state 142

    (62) nestms -> stm nestms .

    }               reduce using rule 62 (nestms -> stm nestms .)


state 143

    (65) stm -> EXIT document . ;

    ;               shift and go to state 178


state 144

    (92) exp -> exp GTEQ . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 179

state 145

    (103) exp -> exp TSUB . IDENTIFIER
    (104) exp -> exp TSUB . ( identifiers )

    IDENTIFIER      shift and go to state 181
    (               shift and go to state 180


state 146

    (100) exp -> exp LSHIFT . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 182

state 147

    (101) exp -> exp TADD . IDENTIFIER
    (102) exp -> exp TADD . ( identifiers )

    IDENTIFIER      shift and go to state 184
    (               shift and go to state 183


state 148

    (88) exp -> exp NEQ . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 185

state 149

    (97) exp -> exp % . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 186

state 150

    (93) exp -> exp + . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 187

state 151

    (95) exp -> exp * . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 188

state 152

    (94) exp -> exp - . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 189

state 153

    (96) exp -> exp / . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 190

state 154

    (72) stm -> exp ; .

    ;               reduce using rule 72 (stm -> exp ; .)
    SHOW            reduce using rule 72 (stm -> exp ; .)
    EXIT            reduce using rule 72 (stm -> exp ; .)
    RETURN          reduce using rule 72 (stm -> exp ; .)
    IF              reduce using rule 72 (stm -> exp ; .)
    WHILE           reduce using rule 72 (stm -> exp ; .)
    {               reduce using rule 72 (stm -> exp ; .)
    -               reduce using rule 72 (stm -> exp ; .)
    !               reduce using rule 72 (stm -> exp ; .)
    IDENTIFIER      reduce using rule 72 (stm -> exp ; .)
    STRING_LITERAL  reduce using rule 72 (stm -> exp ; .)
    TRUE            reduce using rule 72 (stm -> exp ; .)
    FALSE           reduce using rule 72 (stm -> exp ; .)
    INT_LITERAL     reduce using rule 72 (stm -> exp ; .)
    TUPLE           reduce using rule 72 (stm -> exp ; .)
    (               reduce using rule 72 (stm -> exp ; .)
    }               reduce using rule 72 (stm -> exp ; .)


state 155

    (89) exp -> exp < . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 191

state 156

    (90) exp -> exp > . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 192

state 157

    (87) exp -> exp EQ . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 193

state 158

    (98) exp -> exp AND . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 194

state 159

    (91) exp -> exp LTEQ . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 195

state 160

    (99) exp -> exp OR . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 196

state 161

    (114) exp -> ( exp . )
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    )               shift and go to state 197
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160
    LSHIFT          shift and go to state 146
    TADD            shift and go to state 147
    TSUB            shift and go to state 145


state 162

    (14) htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .

    START_TAG       reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    START_CLOSE_TAG reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    START_HOLE      reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    WHATEVER        reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    META            reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    END_HTML_LITERAL reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)


state 163

    (67) stm -> RETURN exp ; .

    ;               reduce using rule 67 (stm -> RETURN exp ; .)
    SHOW            reduce using rule 67 (stm -> RETURN exp ; .)
    EXIT            reduce using rule 67 (stm -> RETURN exp ; .)
    RETURN          reduce using rule 67 (stm -> RETURN exp ; .)
    IF              reduce using rule 67 (stm -> RETURN exp ; .)
    WHILE           reduce using rule 67 (stm -> RETURN exp ; .)
    {               reduce using rule 67 (stm -> RETURN exp ; .)
    -               reduce using rule 67 (stm -> RETURN exp ; .)
    !               reduce using rule 67 (stm -> RETURN exp ; .)
    IDENTIFIER      reduce using rule 67 (stm -> RETURN exp ; .)
    STRING_LITERAL  reduce using rule 67 (stm -> RETURN exp ; .)
    TRUE            reduce using rule 67 (stm -> RETURN exp ; .)
    FALSE           reduce using rule 67 (stm -> RETURN exp ; .)
    INT_LITERAL     reduce using rule 67 (stm -> RETURN exp ; .)
    TUPLE           reduce using rule 67 (stm -> RETURN exp ; .)
    (               reduce using rule 67 (stm -> RETURN exp ; .)
    }               reduce using rule 67 (stm -> RETURN exp ; .)


state 164

    (70) stm -> WHILE ( exp . ) compoundstm
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    )               shift and go to state 198
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160
    LSHIFT          shift and go to state 146
    TADD            shift and go to state 147
    TSUB            shift and go to state 145


state 165

    (86) exp -> lvalue = exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 86 (exp -> lvalue = exp .)
    NEQ             reduce using rule 86 (exp -> lvalue = exp .)
    <               reduce using rule 86 (exp -> lvalue = exp .)
    >               reduce using rule 86 (exp -> lvalue = exp .)
    LTEQ            reduce using rule 86 (exp -> lvalue = exp .)
    GTEQ            reduce using rule 86 (exp -> lvalue = exp .)
    AND             reduce using rule 86 (exp -> lvalue = exp .)
    OR              reduce using rule 86 (exp -> lvalue = exp .)
    LSHIFT          reduce using rule 86 (exp -> lvalue = exp .)
    TADD            reduce using rule 86 (exp -> lvalue = exp .)
    TSUB            reduce using rule 86 (exp -> lvalue = exp .)
    ;               reduce using rule 86 (exp -> lvalue = exp .)
    )               reduce using rule 86 (exp -> lvalue = exp .)
    ,               reduce using rule 86 (exp -> lvalue = exp .)
    }               reduce using rule 86 (exp -> lvalue = exp .)
    ]               reduce using rule 86 (exp -> lvalue = exp .)
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! +               [ reduce using rule 86 (exp -> lvalue = exp .) ]
  ! -               [ reduce using rule 86 (exp -> lvalue = exp .) ]
  ! *               [ reduce using rule 86 (exp -> lvalue = exp .) ]
  ! /               [ reduce using rule 86 (exp -> lvalue = exp .) ]
  ! %               [ reduce using rule 86 (exp -> lvalue = exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 166

    (74) document -> PLUG IDENTIFIER . [ plugs ]

    [               shift and go to state 199


state 167

    (64) stm -> SHOW document receive . ;

    ;               shift and go to state 200


state 168

    (76) receive -> RECEIVE . [ inputs ]

    [               shift and go to state 201


state 169

    (68) stm -> IF ( exp . ) compoundstm
    (69) stm -> IF ( exp . ) compoundstm ELSE compoundstm
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    )               shift and go to state 202
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160
    LSHIFT          shift and go to state 146
    TADD            shift and go to state 147
    TSUB            shift and go to state 145


state 170

    (116) exps -> neexps .

    )               reduce using rule 116 (exps -> neexps .)


state 171

    (108) exp -> IDENTIFIER ( exps . )

    )               shift and go to state 203


state 172

    (117) neexps -> exp .
    (118) neexps -> exp . , neexps
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    )               reduce using rule 117 (neexps -> exp .)
    ,               shift and go to state 204
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160
    LSHIFT          shift and go to state 146
    TADD            shift and go to state 147
    TSUB            shift and go to state 145


state 173

    (120) lvalue -> IDENTIFIER . IDENTIFIER .

    =               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    )               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    EQ              reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    NEQ             reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    <               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    >               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    LTEQ            reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    GTEQ            reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    +               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    -               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    *               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    /               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    %               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    AND             reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    OR              reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    LSHIFT          reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    TADD            reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    TSUB            reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    ;               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    ,               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    }               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)
    ]               reduce using rule 120 (lvalue -> IDENTIFIER . IDENTIFIER .)


state 174

    (122) fieldvalues -> nefieldvalues .

    }               reduce using rule 122 (fieldvalues -> nefieldvalues .)


state 175

    (113) exp -> TUPLE { fieldvalues . }

    }               shift and go to state 205


state 176

    (125) fieldvalue -> IDENTIFIER . = exp

    =               shift and go to state 206


state 177

    (123) nefieldvalues -> fieldvalue .
    (124) nefieldvalues -> fieldvalue . , fieldvalues

    }               reduce using rule 123 (nefieldvalues -> fieldvalue .)
    ,               shift and go to state 207


state 178

    (65) stm -> EXIT document ; .

    ;               reduce using rule 65 (stm -> EXIT document ; .)
    SHOW            reduce using rule 65 (stm -> EXIT document ; .)
    EXIT            reduce using rule 65 (stm -> EXIT document ; .)
    RETURN          reduce using rule 65 (stm -> EXIT document ; .)
    IF              reduce using rule 65 (stm -> EXIT document ; .)
    WHILE           reduce using rule 65 (stm -> EXIT document ; .)
    {               reduce using rule 65 (stm -> EXIT document ; .)
    -               reduce using rule 65 (stm -> EXIT document ; .)
    !               reduce using rule 65 (stm -> EXIT document ; .)
    IDENTIFIER      reduce using rule 65 (stm -> EXIT document ; .)
    STRING_LITERAL  reduce using rule 65 (stm -> EXIT document ; .)
    TRUE            reduce using rule 65 (stm -> EXIT document ; .)
    FALSE           reduce using rule 65 (stm -> EXIT document ; .)
    INT_LITERAL     reduce using rule 65 (stm -> EXIT document ; .)
    TUPLE           reduce using rule 65 (stm -> EXIT document ; .)
    (               reduce using rule 65 (stm -> EXIT document ; .)
    }               reduce using rule 65 (stm -> EXIT document ; .)


state 179

    (92) exp -> exp GTEQ exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 92 (exp -> exp GTEQ exp .)
    NEQ             reduce using rule 92 (exp -> exp GTEQ exp .)
    <               reduce using rule 92 (exp -> exp GTEQ exp .)
    >               reduce using rule 92 (exp -> exp GTEQ exp .)
    LTEQ            reduce using rule 92 (exp -> exp GTEQ exp .)
    GTEQ            reduce using rule 92 (exp -> exp GTEQ exp .)
    AND             reduce using rule 92 (exp -> exp GTEQ exp .)
    OR              reduce using rule 92 (exp -> exp GTEQ exp .)
    LSHIFT          reduce using rule 92 (exp -> exp GTEQ exp .)
    TADD            reduce using rule 92 (exp -> exp GTEQ exp .)
    TSUB            reduce using rule 92 (exp -> exp GTEQ exp .)
    ;               reduce using rule 92 (exp -> exp GTEQ exp .)
    )               reduce using rule 92 (exp -> exp GTEQ exp .)
    ,               reduce using rule 92 (exp -> exp GTEQ exp .)
    }               reduce using rule 92 (exp -> exp GTEQ exp .)
    ]               reduce using rule 92 (exp -> exp GTEQ exp .)
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! +               [ reduce using rule 92 (exp -> exp GTEQ exp .) ]
  ! -               [ reduce using rule 92 (exp -> exp GTEQ exp .) ]
  ! *               [ reduce using rule 92 (exp -> exp GTEQ exp .) ]
  ! /               [ reduce using rule 92 (exp -> exp GTEQ exp .) ]
  ! %               [ reduce using rule 92 (exp -> exp GTEQ exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 180

    (104) exp -> exp TSUB ( . identifiers )
    (38) identifiers -> . IDENTIFIER
    (39) identifiers -> . IDENTIFIER , identifiers

    IDENTIFIER      shift and go to state 28

    identifiers                    shift and go to state 208

state 181

    (103) exp -> exp TSUB IDENTIFIER .

    EQ              reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    NEQ             reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    <               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    >               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    LTEQ            reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    GTEQ            reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    +               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    -               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    *               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    /               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    %               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    AND             reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    OR              reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    LSHIFT          reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    TADD            reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    TSUB            reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    ;               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    )               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    ,               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    }               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)
    ]               reduce using rule 103 (exp -> exp TSUB IDENTIFIER .)


state 182

    (100) exp -> exp LSHIFT exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    LSHIFT          reduce using rule 100 (exp -> exp LSHIFT exp .)
    TADD            reduce using rule 100 (exp -> exp LSHIFT exp .)
    TSUB            reduce using rule 100 (exp -> exp LSHIFT exp .)
    ;               reduce using rule 100 (exp -> exp LSHIFT exp .)
    )               reduce using rule 100 (exp -> exp LSHIFT exp .)
    ,               reduce using rule 100 (exp -> exp LSHIFT exp .)
    }               reduce using rule 100 (exp -> exp LSHIFT exp .)
    ]               reduce using rule 100 (exp -> exp LSHIFT exp .)
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160

  ! EQ              [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! NEQ             [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! <               [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! >               [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! LTEQ            [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! GTEQ            [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! +               [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! -               [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! *               [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! /               [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! %               [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! AND             [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! OR              [ reduce using rule 100 (exp -> exp LSHIFT exp .) ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 183

    (102) exp -> exp TADD ( . identifiers )
    (38) identifiers -> . IDENTIFIER
    (39) identifiers -> . IDENTIFIER , identifiers

    IDENTIFIER      shift and go to state 28

    identifiers                    shift and go to state 209

state 184

    (101) exp -> exp TADD IDENTIFIER .

    EQ              reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    NEQ             reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    <               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    >               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    LTEQ            reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    GTEQ            reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    +               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    -               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    *               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    /               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    %               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    AND             reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    OR              reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    LSHIFT          reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    TADD            reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    TSUB            reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    ;               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    )               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    ,               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    }               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)
    ]               reduce using rule 101 (exp -> exp TADD IDENTIFIER .)


state 185

    (88) exp -> exp NEQ exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 88 (exp -> exp NEQ exp .)
    NEQ             reduce using rule 88 (exp -> exp NEQ exp .)
    <               reduce using rule 88 (exp -> exp NEQ exp .)
    >               reduce using rule 88 (exp -> exp NEQ exp .)
    LTEQ            reduce using rule 88 (exp -> exp NEQ exp .)
    GTEQ            reduce using rule 88 (exp -> exp NEQ exp .)
    AND             reduce using rule 88 (exp -> exp NEQ exp .)
    OR              reduce using rule 88 (exp -> exp NEQ exp .)
    LSHIFT          reduce using rule 88 (exp -> exp NEQ exp .)
    TADD            reduce using rule 88 (exp -> exp NEQ exp .)
    TSUB            reduce using rule 88 (exp -> exp NEQ exp .)
    ;               reduce using rule 88 (exp -> exp NEQ exp .)
    )               reduce using rule 88 (exp -> exp NEQ exp .)
    ,               reduce using rule 88 (exp -> exp NEQ exp .)
    }               reduce using rule 88 (exp -> exp NEQ exp .)
    ]               reduce using rule 88 (exp -> exp NEQ exp .)
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! +               [ reduce using rule 88 (exp -> exp NEQ exp .) ]
  ! -               [ reduce using rule 88 (exp -> exp NEQ exp .) ]
  ! *               [ reduce using rule 88 (exp -> exp NEQ exp .) ]
  ! /               [ reduce using rule 88 (exp -> exp NEQ exp .) ]
  ! %               [ reduce using rule 88 (exp -> exp NEQ exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 186

    (97) exp -> exp % exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 97 (exp -> exp % exp .)
    NEQ             reduce using rule 97 (exp -> exp % exp .)
    <               reduce using rule 97 (exp -> exp % exp .)
    >               reduce using rule 97 (exp -> exp % exp .)
    LTEQ            reduce using rule 97 (exp -> exp % exp .)
    GTEQ            reduce using rule 97 (exp -> exp % exp .)
    +               reduce using rule 97 (exp -> exp % exp .)
    -               reduce using rule 97 (exp -> exp % exp .)
    *               reduce using rule 97 (exp -> exp % exp .)
    /               reduce using rule 97 (exp -> exp % exp .)
    %               reduce using rule 97 (exp -> exp % exp .)
    AND             reduce using rule 97 (exp -> exp % exp .)
    OR              reduce using rule 97 (exp -> exp % exp .)
    LSHIFT          reduce using rule 97 (exp -> exp % exp .)
    TADD            reduce using rule 97 (exp -> exp % exp .)
    TSUB            reduce using rule 97 (exp -> exp % exp .)
    ;               reduce using rule 97 (exp -> exp % exp .)
    )               reduce using rule 97 (exp -> exp % exp .)
    ,               reduce using rule 97 (exp -> exp % exp .)
    }               reduce using rule 97 (exp -> exp % exp .)
    ]               reduce using rule 97 (exp -> exp % exp .)

  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! +               [ shift and go to state 150 ]
  ! -               [ shift and go to state 152 ]
  ! *               [ shift and go to state 151 ]
  ! /               [ shift and go to state 153 ]
  ! %               [ shift and go to state 149 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 187

    (93) exp -> exp + exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 93 (exp -> exp + exp .)
    NEQ             reduce using rule 93 (exp -> exp + exp .)
    <               reduce using rule 93 (exp -> exp + exp .)
    >               reduce using rule 93 (exp -> exp + exp .)
    LTEQ            reduce using rule 93 (exp -> exp + exp .)
    GTEQ            reduce using rule 93 (exp -> exp + exp .)
    +               reduce using rule 93 (exp -> exp + exp .)
    -               reduce using rule 93 (exp -> exp + exp .)
    AND             reduce using rule 93 (exp -> exp + exp .)
    OR              reduce using rule 93 (exp -> exp + exp .)
    LSHIFT          reduce using rule 93 (exp -> exp + exp .)
    TADD            reduce using rule 93 (exp -> exp + exp .)
    TSUB            reduce using rule 93 (exp -> exp + exp .)
    ;               reduce using rule 93 (exp -> exp + exp .)
    )               reduce using rule 93 (exp -> exp + exp .)
    ,               reduce using rule 93 (exp -> exp + exp .)
    }               reduce using rule 93 (exp -> exp + exp .)
    ]               reduce using rule 93 (exp -> exp + exp .)
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! *               [ reduce using rule 93 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 93 (exp -> exp + exp .) ]
  ! %               [ reduce using rule 93 (exp -> exp + exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! +               [ shift and go to state 150 ]
  ! -               [ shift and go to state 152 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 188

    (95) exp -> exp * exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 95 (exp -> exp * exp .)
    NEQ             reduce using rule 95 (exp -> exp * exp .)
    <               reduce using rule 95 (exp -> exp * exp .)
    >               reduce using rule 95 (exp -> exp * exp .)
    LTEQ            reduce using rule 95 (exp -> exp * exp .)
    GTEQ            reduce using rule 95 (exp -> exp * exp .)
    +               reduce using rule 95 (exp -> exp * exp .)
    -               reduce using rule 95 (exp -> exp * exp .)
    *               reduce using rule 95 (exp -> exp * exp .)
    /               reduce using rule 95 (exp -> exp * exp .)
    %               reduce using rule 95 (exp -> exp * exp .)
    AND             reduce using rule 95 (exp -> exp * exp .)
    OR              reduce using rule 95 (exp -> exp * exp .)
    LSHIFT          reduce using rule 95 (exp -> exp * exp .)
    TADD            reduce using rule 95 (exp -> exp * exp .)
    TSUB            reduce using rule 95 (exp -> exp * exp .)
    ;               reduce using rule 95 (exp -> exp * exp .)
    )               reduce using rule 95 (exp -> exp * exp .)
    ,               reduce using rule 95 (exp -> exp * exp .)
    }               reduce using rule 95 (exp -> exp * exp .)
    ]               reduce using rule 95 (exp -> exp * exp .)

  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! +               [ shift and go to state 150 ]
  ! -               [ shift and go to state 152 ]
  ! *               [ shift and go to state 151 ]
  ! /               [ shift and go to state 153 ]
  ! %               [ shift and go to state 149 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 189

    (94) exp -> exp - exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 94 (exp -> exp - exp .)
    NEQ             reduce using rule 94 (exp -> exp - exp .)
    <               reduce using rule 94 (exp -> exp - exp .)
    >               reduce using rule 94 (exp -> exp - exp .)
    LTEQ            reduce using rule 94 (exp -> exp - exp .)
    GTEQ            reduce using rule 94 (exp -> exp - exp .)
    +               reduce using rule 94 (exp -> exp - exp .)
    -               reduce using rule 94 (exp -> exp - exp .)
    AND             reduce using rule 94 (exp -> exp - exp .)
    OR              reduce using rule 94 (exp -> exp - exp .)
    LSHIFT          reduce using rule 94 (exp -> exp - exp .)
    TADD            reduce using rule 94 (exp -> exp - exp .)
    TSUB            reduce using rule 94 (exp -> exp - exp .)
    ;               reduce using rule 94 (exp -> exp - exp .)
    )               reduce using rule 94 (exp -> exp - exp .)
    ,               reduce using rule 94 (exp -> exp - exp .)
    }               reduce using rule 94 (exp -> exp - exp .)
    ]               reduce using rule 94 (exp -> exp - exp .)
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! *               [ reduce using rule 94 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 94 (exp -> exp - exp .) ]
  ! %               [ reduce using rule 94 (exp -> exp - exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! +               [ shift and go to state 150 ]
  ! -               [ shift and go to state 152 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 190

    (96) exp -> exp / exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 96 (exp -> exp / exp .)
    NEQ             reduce using rule 96 (exp -> exp / exp .)
    <               reduce using rule 96 (exp -> exp / exp .)
    >               reduce using rule 96 (exp -> exp / exp .)
    LTEQ            reduce using rule 96 (exp -> exp / exp .)
    GTEQ            reduce using rule 96 (exp -> exp / exp .)
    +               reduce using rule 96 (exp -> exp / exp .)
    -               reduce using rule 96 (exp -> exp / exp .)
    *               reduce using rule 96 (exp -> exp / exp .)
    /               reduce using rule 96 (exp -> exp / exp .)
    %               reduce using rule 96 (exp -> exp / exp .)
    AND             reduce using rule 96 (exp -> exp / exp .)
    OR              reduce using rule 96 (exp -> exp / exp .)
    LSHIFT          reduce using rule 96 (exp -> exp / exp .)
    TADD            reduce using rule 96 (exp -> exp / exp .)
    TSUB            reduce using rule 96 (exp -> exp / exp .)
    ;               reduce using rule 96 (exp -> exp / exp .)
    )               reduce using rule 96 (exp -> exp / exp .)
    ,               reduce using rule 96 (exp -> exp / exp .)
    }               reduce using rule 96 (exp -> exp / exp .)
    ]               reduce using rule 96 (exp -> exp / exp .)

  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! +               [ shift and go to state 150 ]
  ! -               [ shift and go to state 152 ]
  ! *               [ shift and go to state 151 ]
  ! /               [ shift and go to state 153 ]
  ! %               [ shift and go to state 149 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 191

    (89) exp -> exp < exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 89 (exp -> exp < exp .)
    NEQ             reduce using rule 89 (exp -> exp < exp .)
    <               reduce using rule 89 (exp -> exp < exp .)
    >               reduce using rule 89 (exp -> exp < exp .)
    LTEQ            reduce using rule 89 (exp -> exp < exp .)
    GTEQ            reduce using rule 89 (exp -> exp < exp .)
    AND             reduce using rule 89 (exp -> exp < exp .)
    OR              reduce using rule 89 (exp -> exp < exp .)
    LSHIFT          reduce using rule 89 (exp -> exp < exp .)
    TADD            reduce using rule 89 (exp -> exp < exp .)
    TSUB            reduce using rule 89 (exp -> exp < exp .)
    ;               reduce using rule 89 (exp -> exp < exp .)
    )               reduce using rule 89 (exp -> exp < exp .)
    ,               reduce using rule 89 (exp -> exp < exp .)
    }               reduce using rule 89 (exp -> exp < exp .)
    ]               reduce using rule 89 (exp -> exp < exp .)
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! +               [ reduce using rule 89 (exp -> exp < exp .) ]
  ! -               [ reduce using rule 89 (exp -> exp < exp .) ]
  ! *               [ reduce using rule 89 (exp -> exp < exp .) ]
  ! /               [ reduce using rule 89 (exp -> exp < exp .) ]
  ! %               [ reduce using rule 89 (exp -> exp < exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 192

    (90) exp -> exp > exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 90 (exp -> exp > exp .)
    NEQ             reduce using rule 90 (exp -> exp > exp .)
    <               reduce using rule 90 (exp -> exp > exp .)
    >               reduce using rule 90 (exp -> exp > exp .)
    LTEQ            reduce using rule 90 (exp -> exp > exp .)
    GTEQ            reduce using rule 90 (exp -> exp > exp .)
    AND             reduce using rule 90 (exp -> exp > exp .)
    OR              reduce using rule 90 (exp -> exp > exp .)
    LSHIFT          reduce using rule 90 (exp -> exp > exp .)
    TADD            reduce using rule 90 (exp -> exp > exp .)
    TSUB            reduce using rule 90 (exp -> exp > exp .)
    ;               reduce using rule 90 (exp -> exp > exp .)
    )               reduce using rule 90 (exp -> exp > exp .)
    ,               reduce using rule 90 (exp -> exp > exp .)
    }               reduce using rule 90 (exp -> exp > exp .)
    ]               reduce using rule 90 (exp -> exp > exp .)
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! +               [ reduce using rule 90 (exp -> exp > exp .) ]
  ! -               [ reduce using rule 90 (exp -> exp > exp .) ]
  ! *               [ reduce using rule 90 (exp -> exp > exp .) ]
  ! /               [ reduce using rule 90 (exp -> exp > exp .) ]
  ! %               [ reduce using rule 90 (exp -> exp > exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 193

    (87) exp -> exp EQ exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 87 (exp -> exp EQ exp .)
    NEQ             reduce using rule 87 (exp -> exp EQ exp .)
    <               reduce using rule 87 (exp -> exp EQ exp .)
    >               reduce using rule 87 (exp -> exp EQ exp .)
    LTEQ            reduce using rule 87 (exp -> exp EQ exp .)
    GTEQ            reduce using rule 87 (exp -> exp EQ exp .)
    AND             reduce using rule 87 (exp -> exp EQ exp .)
    OR              reduce using rule 87 (exp -> exp EQ exp .)
    LSHIFT          reduce using rule 87 (exp -> exp EQ exp .)
    TADD            reduce using rule 87 (exp -> exp EQ exp .)
    TSUB            reduce using rule 87 (exp -> exp EQ exp .)
    ;               reduce using rule 87 (exp -> exp EQ exp .)
    )               reduce using rule 87 (exp -> exp EQ exp .)
    ,               reduce using rule 87 (exp -> exp EQ exp .)
    }               reduce using rule 87 (exp -> exp EQ exp .)
    ]               reduce using rule 87 (exp -> exp EQ exp .)
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! +               [ reduce using rule 87 (exp -> exp EQ exp .) ]
  ! -               [ reduce using rule 87 (exp -> exp EQ exp .) ]
  ! *               [ reduce using rule 87 (exp -> exp EQ exp .) ]
  ! /               [ reduce using rule 87 (exp -> exp EQ exp .) ]
  ! %               [ reduce using rule 87 (exp -> exp EQ exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 194

    (98) exp -> exp AND exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    AND             reduce using rule 98 (exp -> exp AND exp .)
    OR              reduce using rule 98 (exp -> exp AND exp .)
    LSHIFT          reduce using rule 98 (exp -> exp AND exp .)
    TADD            reduce using rule 98 (exp -> exp AND exp .)
    TSUB            reduce using rule 98 (exp -> exp AND exp .)
    ;               reduce using rule 98 (exp -> exp AND exp .)
    )               reduce using rule 98 (exp -> exp AND exp .)
    ,               reduce using rule 98 (exp -> exp AND exp .)
    }               reduce using rule 98 (exp -> exp AND exp .)
    ]               reduce using rule 98 (exp -> exp AND exp .)
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! EQ              [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! NEQ             [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! <               [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! >               [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! LTEQ            [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! GTEQ            [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! +               [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! -               [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! *               [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! /               [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! %               [ reduce using rule 98 (exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 195

    (91) exp -> exp LTEQ exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 91 (exp -> exp LTEQ exp .)
    NEQ             reduce using rule 91 (exp -> exp LTEQ exp .)
    <               reduce using rule 91 (exp -> exp LTEQ exp .)
    >               reduce using rule 91 (exp -> exp LTEQ exp .)
    LTEQ            reduce using rule 91 (exp -> exp LTEQ exp .)
    GTEQ            reduce using rule 91 (exp -> exp LTEQ exp .)
    AND             reduce using rule 91 (exp -> exp LTEQ exp .)
    OR              reduce using rule 91 (exp -> exp LTEQ exp .)
    LSHIFT          reduce using rule 91 (exp -> exp LTEQ exp .)
    TADD            reduce using rule 91 (exp -> exp LTEQ exp .)
    TSUB            reduce using rule 91 (exp -> exp LTEQ exp .)
    ;               reduce using rule 91 (exp -> exp LTEQ exp .)
    )               reduce using rule 91 (exp -> exp LTEQ exp .)
    ,               reduce using rule 91 (exp -> exp LTEQ exp .)
    }               reduce using rule 91 (exp -> exp LTEQ exp .)
    ]               reduce using rule 91 (exp -> exp LTEQ exp .)
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! +               [ reduce using rule 91 (exp -> exp LTEQ exp .) ]
  ! -               [ reduce using rule 91 (exp -> exp LTEQ exp .) ]
  ! *               [ reduce using rule 91 (exp -> exp LTEQ exp .) ]
  ! /               [ reduce using rule 91 (exp -> exp LTEQ exp .) ]
  ! %               [ reduce using rule 91 (exp -> exp LTEQ exp .) ]
  ! EQ              [ shift and go to state 157 ]
  ! NEQ             [ shift and go to state 148 ]
  ! <               [ shift and go to state 155 ]
  ! >               [ shift and go to state 156 ]
  ! LTEQ            [ shift and go to state 159 ]
  ! GTEQ            [ shift and go to state 144 ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 196

    (99) exp -> exp OR exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    AND             reduce using rule 99 (exp -> exp OR exp .)
    OR              reduce using rule 99 (exp -> exp OR exp .)
    LSHIFT          reduce using rule 99 (exp -> exp OR exp .)
    TADD            reduce using rule 99 (exp -> exp OR exp .)
    TSUB            reduce using rule 99 (exp -> exp OR exp .)
    ;               reduce using rule 99 (exp -> exp OR exp .)
    )               reduce using rule 99 (exp -> exp OR exp .)
    ,               reduce using rule 99 (exp -> exp OR exp .)
    }               reduce using rule 99 (exp -> exp OR exp .)
    ]               reduce using rule 99 (exp -> exp OR exp .)
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149

  ! EQ              [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! NEQ             [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! <               [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! >               [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! LTEQ            [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! GTEQ            [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! +               [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! -               [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! *               [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! /               [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! %               [ reduce using rule 99 (exp -> exp OR exp .) ]
  ! AND             [ shift and go to state 158 ]
  ! OR              [ shift and go to state 160 ]
  ! LSHIFT          [ shift and go to state 146 ]
  ! TADD            [ shift and go to state 147 ]
  ! TSUB            [ shift and go to state 145 ]


state 197

    (114) exp -> ( exp ) .

    EQ              reduce using rule 114 (exp -> ( exp ) .)
    NEQ             reduce using rule 114 (exp -> ( exp ) .)
    <               reduce using rule 114 (exp -> ( exp ) .)
    >               reduce using rule 114 (exp -> ( exp ) .)
    LTEQ            reduce using rule 114 (exp -> ( exp ) .)
    GTEQ            reduce using rule 114 (exp -> ( exp ) .)
    +               reduce using rule 114 (exp -> ( exp ) .)
    -               reduce using rule 114 (exp -> ( exp ) .)
    *               reduce using rule 114 (exp -> ( exp ) .)
    /               reduce using rule 114 (exp -> ( exp ) .)
    %               reduce using rule 114 (exp -> ( exp ) .)
    AND             reduce using rule 114 (exp -> ( exp ) .)
    OR              reduce using rule 114 (exp -> ( exp ) .)
    LSHIFT          reduce using rule 114 (exp -> ( exp ) .)
    TADD            reduce using rule 114 (exp -> ( exp ) .)
    TSUB            reduce using rule 114 (exp -> ( exp ) .)
    ;               reduce using rule 114 (exp -> ( exp ) .)
    )               reduce using rule 114 (exp -> ( exp ) .)
    ,               reduce using rule 114 (exp -> ( exp ) .)
    }               reduce using rule 114 (exp -> ( exp ) .)
    ]               reduce using rule 114 (exp -> ( exp ) .)


state 198

    (70) stm -> WHILE ( exp ) . compoundstm
    (77) compoundstm -> . { variables stms }

    {               shift and go to state 98

    compoundstm                    shift and go to state 210

state 199

    (74) document -> PLUG IDENTIFIER [ . plugs ]
    (78) plugs -> . plug
    (79) plugs -> . plug , plugs
    (80) plug -> . IDENTIFIER = exp

    IDENTIFIER      shift and go to state 212

    plug                           shift and go to state 211
    plugs                          shift and go to state 213

state 200

    (64) stm -> SHOW document receive ; .

    ;               reduce using rule 64 (stm -> SHOW document receive ; .)
    SHOW            reduce using rule 64 (stm -> SHOW document receive ; .)
    EXIT            reduce using rule 64 (stm -> SHOW document receive ; .)
    RETURN          reduce using rule 64 (stm -> SHOW document receive ; .)
    IF              reduce using rule 64 (stm -> SHOW document receive ; .)
    WHILE           reduce using rule 64 (stm -> SHOW document receive ; .)
    {               reduce using rule 64 (stm -> SHOW document receive ; .)
    -               reduce using rule 64 (stm -> SHOW document receive ; .)
    !               reduce using rule 64 (stm -> SHOW document receive ; .)
    IDENTIFIER      reduce using rule 64 (stm -> SHOW document receive ; .)
    STRING_LITERAL  reduce using rule 64 (stm -> SHOW document receive ; .)
    TRUE            reduce using rule 64 (stm -> SHOW document receive ; .)
    FALSE           reduce using rule 64 (stm -> SHOW document receive ; .)
    INT_LITERAL     reduce using rule 64 (stm -> SHOW document receive ; .)
    TUPLE           reduce using rule 64 (stm -> SHOW document receive ; .)
    (               reduce using rule 64 (stm -> SHOW document receive ; .)
    }               reduce using rule 64 (stm -> SHOW document receive ; .)


state 201

    (76) receive -> RECEIVE [ . inputs ]
    (81) inputs -> .
    (82) inputs -> . neinputs
    (83) neinputs -> . input
    (84) neinputs -> . input , neinputs
    (85) input -> . lvalue = IDENTIFIER
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    ]               reduce using rule 81 (inputs -> .)
    IDENTIFIER      shift and go to state 218

    neinputs                       shift and go to state 216
    inputs                         shift and go to state 214
    lvalue                         shift and go to state 215
    input                          shift and go to state 217

state 202

    (68) stm -> IF ( exp ) . compoundstm
    (69) stm -> IF ( exp ) . compoundstm ELSE compoundstm
    (77) compoundstm -> . { variables stms }

    {               shift and go to state 98

    compoundstm                    shift and go to state 219

state 203

    (108) exp -> IDENTIFIER ( exps ) .

    EQ              reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    NEQ             reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    <               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    >               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    LTEQ            reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    GTEQ            reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    +               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    -               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    *               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    /               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    %               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    AND             reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    OR              reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    LSHIFT          reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    TADD            reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    TSUB            reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    ;               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    )               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    ,               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    }               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)
    ]               reduce using rule 108 (exp -> IDENTIFIER ( exps ) .)


state 204

    (118) neexps -> exp , . neexps
    (117) neexps -> . exp
    (118) neexps -> . exp , neexps
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    neexps                         shift and go to state 220
    lvalue                         shift and go to state 110
    exp                            shift and go to state 172

state 205

    (113) exp -> TUPLE { fieldvalues } .

    EQ              reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    NEQ             reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    <               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    >               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    LTEQ            reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    GTEQ            reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    +               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    -               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    *               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    /               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    %               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    AND             reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    OR              reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    LSHIFT          reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    TADD            reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    TSUB            reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    ;               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    )               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    ,               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    }               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)
    ]               reduce using rule 113 (exp -> TUPLE { fieldvalues } .)


state 206

    (125) fieldvalue -> IDENTIFIER = . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 221

state 207

    (124) nefieldvalues -> fieldvalue , . fieldvalues
    (121) fieldvalues -> .
    (122) fieldvalues -> . nefieldvalues
    (123) nefieldvalues -> . fieldvalue
    (124) nefieldvalues -> . fieldvalue , fieldvalues
    (125) fieldvalue -> . IDENTIFIER = exp

    }               reduce using rule 121 (fieldvalues -> .)
    IDENTIFIER      shift and go to state 176

    nefieldvalues                  shift and go to state 174
    fieldvalue                     shift and go to state 177
    fieldvalues                    shift and go to state 222

state 208

    (104) exp -> exp TSUB ( identifiers . )

    )               shift and go to state 223


state 209

    (102) exp -> exp TADD ( identifiers . )

    )               shift and go to state 224


state 210

    (70) stm -> WHILE ( exp ) compoundstm .

    ;               reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    SHOW            reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    EXIT            reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    RETURN          reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    IF              reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    WHILE           reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    {               reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    -               reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    !               reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    IDENTIFIER      reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    STRING_LITERAL  reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    TRUE            reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    FALSE           reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    INT_LITERAL     reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    TUPLE           reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    (               reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)
    }               reduce using rule 70 (stm -> WHILE ( exp ) compoundstm .)


state 211

    (78) plugs -> plug .
    (79) plugs -> plug . , plugs

    ]               reduce using rule 78 (plugs -> plug .)
    ,               shift and go to state 225


state 212

    (80) plug -> IDENTIFIER . = exp

    =               shift and go to state 226


state 213

    (74) document -> PLUG IDENTIFIER [ plugs . ]

    ]               shift and go to state 227


state 214

    (76) receive -> RECEIVE [ inputs . ]

    ]               shift and go to state 228


state 215

    (85) input -> lvalue . = IDENTIFIER

    =               shift and go to state 229


state 216

    (82) inputs -> neinputs .

    ]               reduce using rule 82 (inputs -> neinputs .)


state 217

    (83) neinputs -> input .
    (84) neinputs -> input . , neinputs

    ]               reduce using rule 83 (neinputs -> input .)
    ,               shift and go to state 230


state 218

    (119) lvalue -> IDENTIFIER .
    (120) lvalue -> IDENTIFIER . . IDENTIFIER

    =               reduce using rule 119 (lvalue -> IDENTIFIER .)
    .               shift and go to state 140


state 219

    (68) stm -> IF ( exp ) compoundstm .
    (69) stm -> IF ( exp ) compoundstm . ELSE compoundstm

    ;               reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    SHOW            reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    EXIT            reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    RETURN          reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    IF              reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    WHILE           reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    {               reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    -               reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    !               reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    IDENTIFIER      reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    STRING_LITERAL  reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    TRUE            reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    FALSE           reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    INT_LITERAL     reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    TUPLE           reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    (               reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    }               reduce using rule 68 (stm -> IF ( exp ) compoundstm .)
    ELSE            shift and go to state 231


state 220

    (118) neexps -> exp , neexps .

    )               reduce using rule 118 (neexps -> exp , neexps .)


state 221

    (125) fieldvalue -> IDENTIFIER = exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    ,               reduce using rule 125 (fieldvalue -> IDENTIFIER = exp .)
    }               reduce using rule 125 (fieldvalue -> IDENTIFIER = exp .)
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160
    LSHIFT          shift and go to state 146
    TADD            shift and go to state 147
    TSUB            shift and go to state 145


state 222

    (124) nefieldvalues -> fieldvalue , fieldvalues .

    }               reduce using rule 124 (nefieldvalues -> fieldvalue , fieldvalues .)


state 223

    (104) exp -> exp TSUB ( identifiers ) .

    EQ              reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    NEQ             reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    <               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    >               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    LTEQ            reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    GTEQ            reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    +               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    -               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    *               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    /               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    %               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    AND             reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    OR              reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    LSHIFT          reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    TADD            reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    TSUB            reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    ;               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    )               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    ,               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    }               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)
    ]               reduce using rule 104 (exp -> exp TSUB ( identifiers ) .)


state 224

    (102) exp -> exp TADD ( identifiers ) .

    EQ              reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    NEQ             reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    <               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    >               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    LTEQ            reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    GTEQ            reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    +               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    -               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    *               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    /               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    %               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    AND             reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    OR              reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    LSHIFT          reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    TADD            reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    TSUB            reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    ;               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    )               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    ,               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    }               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)
    ]               reduce using rule 102 (exp -> exp TADD ( identifiers ) .)


state 225

    (79) plugs -> plug , . plugs
    (78) plugs -> . plug
    (79) plugs -> . plug , plugs
    (80) plug -> . IDENTIFIER = exp

    IDENTIFIER      shift and go to state 212

    plug                           shift and go to state 211
    plugs                          shift and go to state 232

state 226

    (80) plug -> IDENTIFIER = . exp
    (86) exp -> . lvalue = exp
    (87) exp -> . exp EQ exp
    (88) exp -> . exp NEQ exp
    (89) exp -> . exp < exp
    (90) exp -> . exp > exp
    (91) exp -> . exp LTEQ exp
    (92) exp -> . exp GTEQ exp
    (93) exp -> . exp + exp
    (94) exp -> . exp - exp
    (95) exp -> . exp * exp
    (96) exp -> . exp / exp
    (97) exp -> . exp % exp
    (98) exp -> . exp AND exp
    (99) exp -> . exp OR exp
    (100) exp -> . exp LSHIFT exp
    (101) exp -> . exp TADD IDENTIFIER
    (102) exp -> . exp TADD ( identifiers )
    (103) exp -> . exp TSUB IDENTIFIER
    (104) exp -> . exp TSUB ( identifiers )
    (105) exp -> . - exp
    (106) exp -> . ! exp
    (107) exp -> . lvalue
    (108) exp -> . IDENTIFIER ( exps )
    (109) exp -> . STRING_LITERAL
    (110) exp -> . TRUE
    (111) exp -> . FALSE
    (112) exp -> . INT_LITERAL
    (113) exp -> . TUPLE { fieldvalues }
    (114) exp -> . ( exp )
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 111
    !               shift and go to state 113
    IDENTIFIER      shift and go to state 118
    STRING_LITERAL  shift and go to state 120
    TRUE            shift and go to state 116
    FALSE           shift and go to state 119
    INT_LITERAL     shift and go to state 126
    TUPLE           shift and go to state 121
    (               shift and go to state 125

    lvalue                         shift and go to state 110
    exp                            shift and go to state 233

state 227

    (74) document -> PLUG IDENTIFIER [ plugs ] .

    RECEIVE         reduce using rule 74 (document -> PLUG IDENTIFIER [ plugs ] .)
    ;               reduce using rule 74 (document -> PLUG IDENTIFIER [ plugs ] .)


state 228

    (76) receive -> RECEIVE [ inputs ] .

    ;               reduce using rule 76 (receive -> RECEIVE [ inputs ] .)


state 229

    (85) input -> lvalue = . IDENTIFIER

    IDENTIFIER      shift and go to state 234


state 230

    (84) neinputs -> input , . neinputs
    (83) neinputs -> . input
    (84) neinputs -> . input , neinputs
    (85) input -> . lvalue = IDENTIFIER
    (119) lvalue -> . IDENTIFIER
    (120) lvalue -> . IDENTIFIER . IDENTIFIER

    IDENTIFIER      shift and go to state 218

    neinputs                       shift and go to state 235
    input                          shift and go to state 217
    lvalue                         shift and go to state 215

state 231

    (69) stm -> IF ( exp ) compoundstm ELSE . compoundstm
    (77) compoundstm -> . { variables stms }

    {               shift and go to state 98

    compoundstm                    shift and go to state 236

state 232

    (79) plugs -> plug , plugs .

    ]               reduce using rule 79 (plugs -> plug , plugs .)


state 233

    (80) plug -> IDENTIFIER = exp .
    (87) exp -> exp . EQ exp
    (88) exp -> exp . NEQ exp
    (89) exp -> exp . < exp
    (90) exp -> exp . > exp
    (91) exp -> exp . LTEQ exp
    (92) exp -> exp . GTEQ exp
    (93) exp -> exp . + exp
    (94) exp -> exp . - exp
    (95) exp -> exp . * exp
    (96) exp -> exp . / exp
    (97) exp -> exp . % exp
    (98) exp -> exp . AND exp
    (99) exp -> exp . OR exp
    (100) exp -> exp . LSHIFT exp
    (101) exp -> exp . TADD IDENTIFIER
    (102) exp -> exp . TADD ( identifiers )
    (103) exp -> exp . TSUB IDENTIFIER
    (104) exp -> exp . TSUB ( identifiers )

    ,               reduce using rule 80 (plug -> IDENTIFIER = exp .)
    ]               reduce using rule 80 (plug -> IDENTIFIER = exp .)
    EQ              shift and go to state 157
    NEQ             shift and go to state 148
    <               shift and go to state 155
    >               shift and go to state 156
    LTEQ            shift and go to state 159
    GTEQ            shift and go to state 144
    +               shift and go to state 150
    -               shift and go to state 152
    *               shift and go to state 151
    /               shift and go to state 153
    %               shift and go to state 149
    AND             shift and go to state 158
    OR              shift and go to state 160
    LSHIFT          shift and go to state 146
    TADD            shift and go to state 147
    TSUB            shift and go to state 145


state 234

    (85) input -> lvalue = IDENTIFIER .

    ,               reduce using rule 85 (input -> lvalue = IDENTIFIER .)
    ]               reduce using rule 85 (input -> lvalue = IDENTIFIER .)


state 235

    (84) neinputs -> input , neinputs .

    ]               reduce using rule 84 (neinputs -> input , neinputs .)


state 236

    (69) stm -> IF ( exp ) compoundstm ELSE compoundstm .

    ;               reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    SHOW            reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    EXIT            reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    RETURN          reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    IF              reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    WHILE           reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    {               reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    -               reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    !               reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    IDENTIFIER      reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    STRING_LITERAL  reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    TRUE            reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    FALSE           reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    INT_LITERAL     reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    TUPLE           reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    (               reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)
    }               reduce using rule 69 (stm -> IF ( exp ) compoundstm ELSE compoundstm .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TUPLE in state 12 resolved as shift
WARNING: shift/reduce conflict for INT in state 12 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 12 resolved as shift
WARNING: shift/reduce conflict for STRING in state 12 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: shift/reduce conflict for TUPLE in state 25 resolved as shift
WARNING: shift/reduce conflict for INT in state 25 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 25 resolved as shift
WARNING: shift/reduce conflict for STRING in state 25 resolved as shift
WARNING: shift/reduce conflict for VOID in state 25 resolved as shift
WARNING: shift/reduce conflict for START_CLOSE_TAG in state 52 resolved as shift
WARNING: shift/reduce conflict for TUPLE in state 98 resolved as shift
