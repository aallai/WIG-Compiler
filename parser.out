Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> service
Rule 1     service -> SERVICE { htmls schemas variables functions sessions }
Rule 2     htmls -> html
Rule 3     htmls -> html htmls
Rule 4     html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
Rule 5     html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;
Rule 6     nehtmlbodies -> htmlbody
Rule 7     nehtmlbodies -> htmlbody nehtmlbodies
Rule 8     htmlbody -> START_TAG IDENTIFIER attributes END_TAG
Rule 9     htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG
Rule 10    htmlbody -> START_HOLE IDENTIFIER END_HOLE
Rule 11    htmlbody -> WHATEVER
Rule 12    htmlbody -> META
Rule 13    htmlbody -> START_TAG INPUT attributes END_TAG
Rule 14    htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
Rule 15    htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG
Rule 16    attributes -> <empty>
Rule 17    attributes -> neattributes
Rule 18    neattributes -> attribute
Rule 19    neattributes -> attribute neattributes
Rule 20    attribute -> attr
Rule 21    attribute -> attr = attr
Rule 22    attr -> IDENTIFIER
Rule 23    attr -> STRING_LITERAL
Rule 24    schemas -> <empty>
Rule 25    schemas -> neschemas
Rule 26    neschemas -> schema
Rule 27    neschemas -> schema neschemas
Rule 28    schema -> SCHEMA IDENTIFIER { fields }
Rule 29    fields -> <empty>
Rule 30    fields -> nefields
Rule 31    nefields -> field
Rule 32    nefields -> field nefields
Rule 33    field -> simpletype IDENTIFIER ;
Rule 34    variables -> <empty>
Rule 35    variables -> nevariables
Rule 36    nevariables -> variable
Rule 37    nevariables -> variable nevariables
Rule 38    variable -> type identifiers ;
Rule 39    identifiers -> IDENTIFIER
Rule 40    identifiers -> IDENTIFIER , identifiers
Rule 41    simpletype -> INT
Rule 42    simpletype -> BOOL
Rule 43    simpletype -> STRING
Rule 44    simpletype -> VOID
Rule 45    type -> simpletype
Rule 46    type -> TUPLE IDENTIFIER
Rule 47    functions -> <empty>
Rule 48    functions -> nefunctions
Rule 49    nefunctions -> function
Rule 50    nefunctions -> function nefunctions
Rule 51    function -> type IDENTIFIER ( arguments ) compoundstm
Rule 52    arguments -> <empty>
Rule 53    arguments -> nearguments
Rule 54    nearguments -> argument
Rule 55    nearguments -> argument , nearguments
Rule 56    argument -> type IDENTIFIER
Rule 57    sessions -> session
Rule 58    sessions -> session sessions
Rule 59    session -> SESSION IDENTIFIER ( ) compoundstm
Rule 60    stms -> <empty>
Rule 61    stms -> nestms
Rule 62    nestms -> stm
Rule 63    nestms -> stm nestms
Rule 64    stm -> ;
Rule 65    stm -> SHOW document receive ;
Rule 66    stm -> EXIT document ;
Rule 67    stm -> RETURN ;
Rule 68    stm -> RETURN exp ;
Rule 69    stm -> IF ( exp ) stm
Rule 70    stm -> IF ( exp ) stm ELSE stm
Rule 71    stm -> WHILE ( exp ) stm
Rule 72    stm -> compoundstm
Rule 73    stm -> exp ;
Rule 74    document -> IDENTIFIER
Rule 75    document -> PLUG IDENTIFIER [ plugs ]
Rule 76    receive -> <empty>
Rule 77    receive -> RECEIVE [ inputs ]
Rule 78    compoundstm -> { variables stms }
Rule 79    plugs -> plug
Rule 80    plugs -> plug , plugs
Rule 81    plug -> IDENTIFIER = exp
Rule 82    inputs -> <empty>
Rule 83    inputs -> neinputs
Rule 84    neinputs -> input
Rule 85    neinputs -> input , neinputs
Rule 86    input -> lvalue = IDENTIFIER
Rule 87    exp -> lvalue = exp
Rule 88    exp -> exp EQ exp
Rule 89    exp -> exp NEQ exp
Rule 90    exp -> exp < exp
Rule 91    exp -> exp > exp
Rule 92    exp -> exp LTEQ exp
Rule 93    exp -> exp GTEQ exp
Rule 94    exp -> exp + exp
Rule 95    exp -> exp - exp
Rule 96    exp -> exp * exp
Rule 97    exp -> exp / exp
Rule 98    exp -> exp % exp
Rule 99    exp -> exp AND exp
Rule 100   exp -> exp OR exp
Rule 101   exp -> exp LSHIFT exp
Rule 102   exp -> exp TADD IDENTIFIER
Rule 103   exp -> exp TADD ( identifiers )
Rule 104   exp -> exp TSUB IDENTIFIER
Rule 105   exp -> exp TSUB ( identifiers )
Rule 106   exp -> - exp
Rule 107   exp -> ! exp
Rule 108   exp -> lvalue
Rule 109   exp -> IDENTIFIER ( exps )
Rule 110   exp -> STRING_LITERAL
Rule 111   exp -> TRUE
Rule 112   exp -> FALSE
Rule 113   exp -> INT_LITERAL
Rule 114   exp -> TUPLE { fieldvalues }
Rule 115   exp -> ( exp )
Rule 116   exps -> <empty>
Rule 117   exps -> neexps
Rule 118   neexps -> exp
Rule 119   neexps -> exp , neexps
Rule 120   lvalue -> IDENTIFIER
Rule 121   lvalue -> IDENTIFIER . IDENTIFIER
Rule 122   fieldvalues -> <empty>
Rule 123   fieldvalues -> nefieldvalues
Rule 124   nefieldvalues -> fieldvalue
Rule 125   nefieldvalues -> fieldvalue , fieldvalues
Rule 126   fieldvalue -> IDENTIFIER = exp

Terminals, with rules where they appear

!                    : 107
%                    : 98
(                    : 51 59 69 70 71 103 105 109 115
)                    : 51 59 69 70 71 103 105 109 115
*                    : 96
+                    : 94
,                    : 40 55 80 85 119 125
-                    : 95 106
.                    : 121
/                    : 97
;                    : 4 5 33 38 64 65 66 67 68 73
<                    : 90
=                    : 4 5 21 81 86 87 126
>                    : 91
AND                  : 99
BOOL                 : 42
CONST                : 4 5
ELSE                 : 70
END_HOLE             : 10
END_HTML_LITERAL     : 4 5
END_TAG              : 8 9 13 14 14 15 15
EQ                   : 88
EXIT                 : 66
FALSE                : 112
GTEQ                 : 93
HTML                 : 4 5
IDENTIFIER           : 4 5 8 9 10 22 28 33 39 40 46 51 56 59 74 75 81 86 102 104 109 120 121 121 126
IF                   : 69 70
INPUT                : 13
INT                  : 41
INT_LITERAL          : 113
LSHIFT               : 101
LTEQ                 : 92
META                 : 12
NEQ                  : 89
OR                   : 100
PLUG                 : 75
RECEIVE              : 77
RETURN               : 67 68
SCHEMA               : 28
SELECT               : 14 14 15 15
SERVICE              : 1
SESSION              : 59
SHOW                 : 65
START_CLOSE_TAG      : 9 14 15
START_HOLE           : 10
START_HTML_LITERAL   : 4 5
START_TAG            : 8 13 14 15
STRING               : 43
STRING_LITERAL       : 23 110
TADD                 : 102 103
TRUE                 : 111
TSUB                 : 104 105
TUPLE                : 46 114
VOID                 : 44
WHATEVER             : 11
WHILE                : 71
[                    : 75 77
]                    : 75 77
error                : 
{                    : 1 28 78 114
}                    : 1 28 78 114

Nonterminals, with rules where they appear

argument             : 54 55
arguments            : 51
attr                 : 20 21 21
attribute            : 18 19
attributes           : 8 13 14 15
compoundstm          : 51 59 72
document             : 65 66
exp                  : 68 69 70 71 73 81 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 101 102 103 104 105 106 107 115 118 119 126
exps                 : 109
field                : 31 32
fields               : 28
fieldvalue           : 124 125
fieldvalues          : 114 125
function             : 49 50
functions            : 1
html                 : 2 3
htmlbody             : 6 7
htmls                : 1 3
identifiers          : 38 40 103 105
input                : 84 85
inputs               : 77
lvalue               : 86 87 108
nearguments          : 53 55
neattributes         : 17 19
neexps               : 117 119
nefields             : 30 32
nefieldvalues        : 123
nefunctions          : 48 50
nehtmlbodies         : 4 7 14
neinputs             : 83 85
neschemas            : 25 27
nestms               : 61 63
nevariables          : 35 37
plug                 : 79 80
plugs                : 75 80
receive              : 65
schema               : 26 27
schemas              : 1
service              : 0
session              : 57 58
sessions             : 1 58
simpletype           : 33 45
stm                  : 62 63 69 70 70 71
stms                 : 78
type                 : 38 51 56
variable             : 36 37
variables            : 1 78

Parsing method: LALR

state 0

    (0) S' -> . service
    (1) service -> . SERVICE { htmls schemas variables functions sessions }

    SERVICE         shift and go to state 2

    service                        shift and go to state 1

state 1

    (0) S' -> service .



state 2

    (1) service -> SERVICE . { htmls schemas variables functions sessions }

    {               shift and go to state 3


state 3

    (1) service -> SERVICE { . htmls schemas variables functions sessions }
    (2) htmls -> . html
    (3) htmls -> . html htmls
    (4) html -> . CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> . CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;

    CONST           shift and go to state 4

    htmls                          shift and go to state 6
    html                           shift and go to state 5

state 4

    (4) html -> CONST . HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST . HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;

    HTML            shift and go to state 7


state 5

    (2) htmls -> html .
    (3) htmls -> html . htmls
    (2) htmls -> . html
    (3) htmls -> . html htmls
    (4) html -> . CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> . CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;

    SCHEMA          reduce using rule 2 (htmls -> html .)
    TUPLE           reduce using rule 2 (htmls -> html .)
    INT             reduce using rule 2 (htmls -> html .)
    BOOL            reduce using rule 2 (htmls -> html .)
    STRING          reduce using rule 2 (htmls -> html .)
    VOID            reduce using rule 2 (htmls -> html .)
    SESSION         reduce using rule 2 (htmls -> html .)
    CONST           shift and go to state 4

    html                           shift and go to state 5
    htmls                          shift and go to state 8

state 6

    (1) service -> SERVICE { htmls . schemas variables functions sessions }
    (24) schemas -> .
    (25) schemas -> . neschemas
    (26) neschemas -> . schema
    (27) neschemas -> . schema neschemas
    (28) schema -> . SCHEMA IDENTIFIER { fields }

    TUPLE           reduce using rule 24 (schemas -> .)
    INT             reduce using rule 24 (schemas -> .)
    BOOL            reduce using rule 24 (schemas -> .)
    STRING          reduce using rule 24 (schemas -> .)
    VOID            reduce using rule 24 (schemas -> .)
    SESSION         reduce using rule 24 (schemas -> .)
    SCHEMA          shift and go to state 9

    neschemas                      shift and go to state 10
    schema                         shift and go to state 11
    schemas                        shift and go to state 12

state 7

    (4) html -> CONST HTML . IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST HTML . IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ;

    IDENTIFIER      shift and go to state 13


state 8

    (3) htmls -> html htmls .

    SCHEMA          reduce using rule 3 (htmls -> html htmls .)
    TUPLE           reduce using rule 3 (htmls -> html htmls .)
    INT             reduce using rule 3 (htmls -> html htmls .)
    BOOL            reduce using rule 3 (htmls -> html htmls .)
    STRING          reduce using rule 3 (htmls -> html htmls .)
    VOID            reduce using rule 3 (htmls -> html htmls .)
    SESSION         reduce using rule 3 (htmls -> html htmls .)


state 9

    (28) schema -> SCHEMA . IDENTIFIER { fields }

    IDENTIFIER      shift and go to state 14


state 10

    (25) schemas -> neschemas .

    TUPLE           reduce using rule 25 (schemas -> neschemas .)
    INT             reduce using rule 25 (schemas -> neschemas .)
    BOOL            reduce using rule 25 (schemas -> neschemas .)
    STRING          reduce using rule 25 (schemas -> neschemas .)
    VOID            reduce using rule 25 (schemas -> neschemas .)
    SESSION         reduce using rule 25 (schemas -> neschemas .)


state 11

    (26) neschemas -> schema .
    (27) neschemas -> schema . neschemas
    (26) neschemas -> . schema
    (27) neschemas -> . schema neschemas
    (28) schema -> . SCHEMA IDENTIFIER { fields }

    TUPLE           reduce using rule 26 (neschemas -> schema .)
    INT             reduce using rule 26 (neschemas -> schema .)
    BOOL            reduce using rule 26 (neschemas -> schema .)
    STRING          reduce using rule 26 (neschemas -> schema .)
    VOID            reduce using rule 26 (neschemas -> schema .)
    SESSION         reduce using rule 26 (neschemas -> schema .)
    SCHEMA          shift and go to state 9

    neschemas                      shift and go to state 15
    schema                         shift and go to state 11

state 12

    (1) service -> SERVICE { htmls schemas . variables functions sessions }
    (34) variables -> .
    (35) variables -> . nevariables
    (36) nevariables -> . variable
    (37) nevariables -> . variable nevariables
    (38) variable -> . type identifiers ;
    (45) type -> . simpletype
    (46) type -> . TUPLE IDENTIFIER
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

  ! shift/reduce conflict for TUPLE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    SESSION         reduce using rule 34 (variables -> .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

  ! TUPLE           [ reduce using rule 34 (variables -> .) ]
  ! INT             [ reduce using rule 34 (variables -> .) ]
  ! BOOL            [ reduce using rule 34 (variables -> .) ]
  ! STRING          [ reduce using rule 34 (variables -> .) ]
  ! VOID            [ reduce using rule 34 (variables -> .) ]

    simpletype                     shift and go to state 16
    nevariables                    shift and go to state 17
    variables                      shift and go to state 20
    variable                       shift and go to state 25
    type                           shift and go to state 19

state 13

    (4) html -> CONST HTML IDENTIFIER . = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST HTML IDENTIFIER . = START_HTML_LITERAL END_HTML_LITERAL ;

    =               shift and go to state 26


state 14

    (28) schema -> SCHEMA IDENTIFIER . { fields }

    {               shift and go to state 27


state 15

    (27) neschemas -> schema neschemas .

    TUPLE           reduce using rule 27 (neschemas -> schema neschemas .)
    INT             reduce using rule 27 (neschemas -> schema neschemas .)
    BOOL            reduce using rule 27 (neschemas -> schema neschemas .)
    STRING          reduce using rule 27 (neschemas -> schema neschemas .)
    VOID            reduce using rule 27 (neschemas -> schema neschemas .)
    SESSION         reduce using rule 27 (neschemas -> schema neschemas .)


state 16

    (45) type -> simpletype .

    IDENTIFIER      reduce using rule 45 (type -> simpletype .)


state 17

    (35) variables -> nevariables .

    ;               reduce using rule 35 (variables -> nevariables .)
    SHOW            reduce using rule 35 (variables -> nevariables .)
    EXIT            reduce using rule 35 (variables -> nevariables .)
    RETURN          reduce using rule 35 (variables -> nevariables .)
    IF              reduce using rule 35 (variables -> nevariables .)
    WHILE           reduce using rule 35 (variables -> nevariables .)
    {               reduce using rule 35 (variables -> nevariables .)
    -               reduce using rule 35 (variables -> nevariables .)
    !               reduce using rule 35 (variables -> nevariables .)
    IDENTIFIER      reduce using rule 35 (variables -> nevariables .)
    STRING_LITERAL  reduce using rule 35 (variables -> nevariables .)
    TRUE            reduce using rule 35 (variables -> nevariables .)
    FALSE           reduce using rule 35 (variables -> nevariables .)
    INT_LITERAL     reduce using rule 35 (variables -> nevariables .)
    TUPLE           reduce using rule 35 (variables -> nevariables .)
    (               reduce using rule 35 (variables -> nevariables .)
    }               reduce using rule 35 (variables -> nevariables .)
    INT             reduce using rule 35 (variables -> nevariables .)
    BOOL            reduce using rule 35 (variables -> nevariables .)
    STRING          reduce using rule 35 (variables -> nevariables .)
    VOID            reduce using rule 35 (variables -> nevariables .)
    SESSION         reduce using rule 35 (variables -> nevariables .)


state 18

    (41) simpletype -> INT .

    IDENTIFIER      reduce using rule 41 (simpletype -> INT .)


state 19

    (38) variable -> type . identifiers ;
    (39) identifiers -> . IDENTIFIER
    (40) identifiers -> . IDENTIFIER , identifiers

    IDENTIFIER      shift and go to state 28

    identifiers                    shift and go to state 29

state 20

    (1) service -> SERVICE { htmls schemas variables . functions sessions }
    (47) functions -> .
    (48) functions -> . nefunctions
    (49) nefunctions -> . function
    (50) nefunctions -> . function nefunctions
    (51) function -> . type IDENTIFIER ( arguments ) compoundstm
    (45) type -> . simpletype
    (46) type -> . TUPLE IDENTIFIER
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

    SESSION         reduce using rule 47 (functions -> .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    function                       shift and go to state 32
    functions                      shift and go to state 30
    simpletype                     shift and go to state 16
    nefunctions                    shift and go to state 33
    type                           shift and go to state 31

state 21

    (46) type -> TUPLE . IDENTIFIER

    IDENTIFIER      shift and go to state 34


state 22

    (44) simpletype -> VOID .

    IDENTIFIER      reduce using rule 44 (simpletype -> VOID .)


state 23

    (42) simpletype -> BOOL .

    IDENTIFIER      reduce using rule 42 (simpletype -> BOOL .)


state 24

    (43) simpletype -> STRING .

    IDENTIFIER      reduce using rule 43 (simpletype -> STRING .)


state 25

    (36) nevariables -> variable .
    (37) nevariables -> variable . nevariables
    (36) nevariables -> . variable
    (37) nevariables -> . variable nevariables
    (38) variable -> . type identifiers ;
    (45) type -> . simpletype
    (46) type -> . TUPLE IDENTIFIER
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

  ! shift/reduce conflict for TUPLE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    ;               reduce using rule 36 (nevariables -> variable .)
    SHOW            reduce using rule 36 (nevariables -> variable .)
    EXIT            reduce using rule 36 (nevariables -> variable .)
    RETURN          reduce using rule 36 (nevariables -> variable .)
    IF              reduce using rule 36 (nevariables -> variable .)
    WHILE           reduce using rule 36 (nevariables -> variable .)
    {               reduce using rule 36 (nevariables -> variable .)
    -               reduce using rule 36 (nevariables -> variable .)
    !               reduce using rule 36 (nevariables -> variable .)
    IDENTIFIER      reduce using rule 36 (nevariables -> variable .)
    STRING_LITERAL  reduce using rule 36 (nevariables -> variable .)
    TRUE            reduce using rule 36 (nevariables -> variable .)
    FALSE           reduce using rule 36 (nevariables -> variable .)
    INT_LITERAL     reduce using rule 36 (nevariables -> variable .)
    (               reduce using rule 36 (nevariables -> variable .)
    }               reduce using rule 36 (nevariables -> variable .)
    SESSION         reduce using rule 36 (nevariables -> variable .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

  ! TUPLE           [ reduce using rule 36 (nevariables -> variable .) ]
  ! INT             [ reduce using rule 36 (nevariables -> variable .) ]
  ! BOOL            [ reduce using rule 36 (nevariables -> variable .) ]
  ! STRING          [ reduce using rule 36 (nevariables -> variable .) ]
  ! VOID            [ reduce using rule 36 (nevariables -> variable .) ]

    variable                       shift and go to state 25
    simpletype                     shift and go to state 16
    type                           shift and go to state 19
    nevariables                    shift and go to state 35

state 26

    (4) html -> CONST HTML IDENTIFIER = . START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST HTML IDENTIFIER = . START_HTML_LITERAL END_HTML_LITERAL ;

    START_HTML_LITERAL shift and go to state 36


state 27

    (28) schema -> SCHEMA IDENTIFIER { . fields }
    (29) fields -> .
    (30) fields -> . nefields
    (31) nefields -> . field
    (32) nefields -> . field nefields
    (33) field -> . simpletype IDENTIFIER ;
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

    }               reduce using rule 29 (fields -> .)
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    fields                         shift and go to state 38
    simpletype                     shift and go to state 40
    nefields                       shift and go to state 37
    field                          shift and go to state 39

state 28

    (39) identifiers -> IDENTIFIER .
    (40) identifiers -> IDENTIFIER . , identifiers

    )               reduce using rule 39 (identifiers -> IDENTIFIER .)
    ;               reduce using rule 39 (identifiers -> IDENTIFIER .)
    ,               shift and go to state 41


state 29

    (38) variable -> type identifiers . ;

    ;               shift and go to state 42


state 30

    (1) service -> SERVICE { htmls schemas variables functions . sessions }
    (57) sessions -> . session
    (58) sessions -> . session sessions
    (59) session -> . SESSION IDENTIFIER ( ) compoundstm

    SESSION         shift and go to state 44

    sessions                       shift and go to state 45
    session                        shift and go to state 43

state 31

    (51) function -> type . IDENTIFIER ( arguments ) compoundstm

    IDENTIFIER      shift and go to state 46


state 32

    (49) nefunctions -> function .
    (50) nefunctions -> function . nefunctions
    (49) nefunctions -> . function
    (50) nefunctions -> . function nefunctions
    (51) function -> . type IDENTIFIER ( arguments ) compoundstm
    (45) type -> . simpletype
    (46) type -> . TUPLE IDENTIFIER
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

    SESSION         reduce using rule 49 (nefunctions -> function .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    function                       shift and go to state 32
    simpletype                     shift and go to state 16
    nefunctions                    shift and go to state 47
    type                           shift and go to state 31

state 33

    (48) functions -> nefunctions .

    SESSION         reduce using rule 48 (functions -> nefunctions .)


state 34

    (46) type -> TUPLE IDENTIFIER .

    IDENTIFIER      reduce using rule 46 (type -> TUPLE IDENTIFIER .)


state 35

    (37) nevariables -> variable nevariables .

    ;               reduce using rule 37 (nevariables -> variable nevariables .)
    SHOW            reduce using rule 37 (nevariables -> variable nevariables .)
    EXIT            reduce using rule 37 (nevariables -> variable nevariables .)
    RETURN          reduce using rule 37 (nevariables -> variable nevariables .)
    IF              reduce using rule 37 (nevariables -> variable nevariables .)
    WHILE           reduce using rule 37 (nevariables -> variable nevariables .)
    {               reduce using rule 37 (nevariables -> variable nevariables .)
    -               reduce using rule 37 (nevariables -> variable nevariables .)
    !               reduce using rule 37 (nevariables -> variable nevariables .)
    IDENTIFIER      reduce using rule 37 (nevariables -> variable nevariables .)
    STRING_LITERAL  reduce using rule 37 (nevariables -> variable nevariables .)
    TRUE            reduce using rule 37 (nevariables -> variable nevariables .)
    FALSE           reduce using rule 37 (nevariables -> variable nevariables .)
    INT_LITERAL     reduce using rule 37 (nevariables -> variable nevariables .)
    TUPLE           reduce using rule 37 (nevariables -> variable nevariables .)
    (               reduce using rule 37 (nevariables -> variable nevariables .)
    }               reduce using rule 37 (nevariables -> variable nevariables .)
    INT             reduce using rule 37 (nevariables -> variable nevariables .)
    BOOL            reduce using rule 37 (nevariables -> variable nevariables .)
    STRING          reduce using rule 37 (nevariables -> variable nevariables .)
    VOID            reduce using rule 37 (nevariables -> variable nevariables .)
    SESSION         reduce using rule 37 (nevariables -> variable nevariables .)


state 36

    (4) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL . nehtmlbodies END_HTML_LITERAL ;
    (5) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL . END_HTML_LITERAL ;
    (6) nehtmlbodies -> . htmlbody
    (7) nehtmlbodies -> . htmlbody nehtmlbodies
    (8) htmlbody -> . START_TAG IDENTIFIER attributes END_TAG
    (9) htmlbody -> . START_CLOSE_TAG IDENTIFIER END_TAG
    (10) htmlbody -> . START_HOLE IDENTIFIER END_HOLE
    (11) htmlbody -> . WHATEVER
    (12) htmlbody -> . META
    (13) htmlbody -> . START_TAG INPUT attributes END_TAG
    (14) htmlbody -> . START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (15) htmlbody -> . START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG

    END_HTML_LITERAL shift and go to state 54
    START_TAG       shift and go to state 50
    START_CLOSE_TAG shift and go to state 49
    START_HOLE      shift and go to state 48
    WHATEVER        shift and go to state 51
    META            shift and go to state 53

    nehtmlbodies                   shift and go to state 55
    htmlbody                       shift and go to state 52

state 37

    (30) fields -> nefields .

    }               reduce using rule 30 (fields -> nefields .)


state 38

    (28) schema -> SCHEMA IDENTIFIER { fields . }

    }               shift and go to state 56


state 39

    (31) nefields -> field .
    (32) nefields -> field . nefields
    (31) nefields -> . field
    (32) nefields -> . field nefields
    (33) field -> . simpletype IDENTIFIER ;
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

    }               reduce using rule 31 (nefields -> field .)
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    field                          shift and go to state 39
    nefields                       shift and go to state 57
    simpletype                     shift and go to state 40

state 40

    (33) field -> simpletype . IDENTIFIER ;

    IDENTIFIER      shift and go to state 58


state 41

    (40) identifiers -> IDENTIFIER , . identifiers
    (39) identifiers -> . IDENTIFIER
    (40) identifiers -> . IDENTIFIER , identifiers

    IDENTIFIER      shift and go to state 28

    identifiers                    shift and go to state 59

state 42

    (38) variable -> type identifiers ; .

    TUPLE           reduce using rule 38 (variable -> type identifiers ; .)
    INT             reduce using rule 38 (variable -> type identifiers ; .)
    BOOL            reduce using rule 38 (variable -> type identifiers ; .)
    STRING          reduce using rule 38 (variable -> type identifiers ; .)
    VOID            reduce using rule 38 (variable -> type identifiers ; .)
    SESSION         reduce using rule 38 (variable -> type identifiers ; .)
    ;               reduce using rule 38 (variable -> type identifiers ; .)
    SHOW            reduce using rule 38 (variable -> type identifiers ; .)
    EXIT            reduce using rule 38 (variable -> type identifiers ; .)
    RETURN          reduce using rule 38 (variable -> type identifiers ; .)
    IF              reduce using rule 38 (variable -> type identifiers ; .)
    WHILE           reduce using rule 38 (variable -> type identifiers ; .)
    {               reduce using rule 38 (variable -> type identifiers ; .)
    -               reduce using rule 38 (variable -> type identifiers ; .)
    !               reduce using rule 38 (variable -> type identifiers ; .)
    IDENTIFIER      reduce using rule 38 (variable -> type identifiers ; .)
    STRING_LITERAL  reduce using rule 38 (variable -> type identifiers ; .)
    TRUE            reduce using rule 38 (variable -> type identifiers ; .)
    FALSE           reduce using rule 38 (variable -> type identifiers ; .)
    INT_LITERAL     reduce using rule 38 (variable -> type identifiers ; .)
    (               reduce using rule 38 (variable -> type identifiers ; .)
    }               reduce using rule 38 (variable -> type identifiers ; .)


state 43

    (57) sessions -> session .
    (58) sessions -> session . sessions
    (57) sessions -> . session
    (58) sessions -> . session sessions
    (59) session -> . SESSION IDENTIFIER ( ) compoundstm

    }               reduce using rule 57 (sessions -> session .)
    SESSION         shift and go to state 44

    session                        shift and go to state 43
    sessions                       shift and go to state 60

state 44

    (59) session -> SESSION . IDENTIFIER ( ) compoundstm

    IDENTIFIER      shift and go to state 61


state 45

    (1) service -> SERVICE { htmls schemas variables functions sessions . }

    }               shift and go to state 62


state 46

    (51) function -> type IDENTIFIER . ( arguments ) compoundstm

    (               shift and go to state 63


state 47

    (50) nefunctions -> function nefunctions .

    SESSION         reduce using rule 50 (nefunctions -> function nefunctions .)


state 48

    (10) htmlbody -> START_HOLE . IDENTIFIER END_HOLE

    IDENTIFIER      shift and go to state 64


state 49

    (9) htmlbody -> START_CLOSE_TAG . IDENTIFIER END_TAG

    IDENTIFIER      shift and go to state 65


state 50

    (8) htmlbody -> START_TAG . IDENTIFIER attributes END_TAG
    (13) htmlbody -> START_TAG . INPUT attributes END_TAG
    (14) htmlbody -> START_TAG . SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (15) htmlbody -> START_TAG . SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG

    IDENTIFIER      shift and go to state 67
    INPUT           shift and go to state 66
    SELECT          shift and go to state 68


state 51

    (11) htmlbody -> WHATEVER .

    START_TAG       reduce using rule 11 (htmlbody -> WHATEVER .)
    START_CLOSE_TAG reduce using rule 11 (htmlbody -> WHATEVER .)
    START_HOLE      reduce using rule 11 (htmlbody -> WHATEVER .)
    WHATEVER        reduce using rule 11 (htmlbody -> WHATEVER .)
    META            reduce using rule 11 (htmlbody -> WHATEVER .)
    END_HTML_LITERAL reduce using rule 11 (htmlbody -> WHATEVER .)


state 52

    (6) nehtmlbodies -> htmlbody .
    (7) nehtmlbodies -> htmlbody . nehtmlbodies
    (6) nehtmlbodies -> . htmlbody
    (7) nehtmlbodies -> . htmlbody nehtmlbodies
    (8) htmlbody -> . START_TAG IDENTIFIER attributes END_TAG
    (9) htmlbody -> . START_CLOSE_TAG IDENTIFIER END_TAG
    (10) htmlbody -> . START_HOLE IDENTIFIER END_HOLE
    (11) htmlbody -> . WHATEVER
    (12) htmlbody -> . META
    (13) htmlbody -> . START_TAG INPUT attributes END_TAG
    (14) htmlbody -> . START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (15) htmlbody -> . START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG

  ! shift/reduce conflict for START_CLOSE_TAG resolved as shift
    END_HTML_LITERAL reduce using rule 6 (nehtmlbodies -> htmlbody .)
    START_TAG       shift and go to state 50
    START_CLOSE_TAG shift and go to state 49
    START_HOLE      shift and go to state 48
    WHATEVER        shift and go to state 51
    META            shift and go to state 53

  ! START_CLOSE_TAG [ reduce using rule 6 (nehtmlbodies -> htmlbody .) ]

    nehtmlbodies                   shift and go to state 69
    htmlbody                       shift and go to state 52

state 53

    (12) htmlbody -> META .

    START_TAG       reduce using rule 12 (htmlbody -> META .)
    START_CLOSE_TAG reduce using rule 12 (htmlbody -> META .)
    START_HOLE      reduce using rule 12 (htmlbody -> META .)
    WHATEVER        reduce using rule 12 (htmlbody -> META .)
    META            reduce using rule 12 (htmlbody -> META .)
    END_HTML_LITERAL reduce using rule 12 (htmlbody -> META .)


state 54

    (5) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL . ;

    ;               shift and go to state 70


state 55

    (4) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies . END_HTML_LITERAL ;

    END_HTML_LITERAL shift and go to state 71


state 56

    (28) schema -> SCHEMA IDENTIFIER { fields } .

    SCHEMA          reduce using rule 28 (schema -> SCHEMA IDENTIFIER { fields } .)
    TUPLE           reduce using rule 28 (schema -> SCHEMA IDENTIFIER { fields } .)
    INT             reduce using rule 28 (schema -> SCHEMA IDENTIFIER { fields } .)
    BOOL            reduce using rule 28 (schema -> SCHEMA IDENTIFIER { fields } .)
    STRING          reduce using rule 28 (schema -> SCHEMA IDENTIFIER { fields } .)
    VOID            reduce using rule 28 (schema -> SCHEMA IDENTIFIER { fields } .)
    SESSION         reduce using rule 28 (schema -> SCHEMA IDENTIFIER { fields } .)


state 57

    (32) nefields -> field nefields .

    }               reduce using rule 32 (nefields -> field nefields .)


state 58

    (33) field -> simpletype IDENTIFIER . ;

    ;               shift and go to state 72


state 59

    (40) identifiers -> IDENTIFIER , identifiers .

    )               reduce using rule 40 (identifiers -> IDENTIFIER , identifiers .)
    ;               reduce using rule 40 (identifiers -> IDENTIFIER , identifiers .)


state 60

    (58) sessions -> session sessions .

    }               reduce using rule 58 (sessions -> session sessions .)


state 61

    (59) session -> SESSION IDENTIFIER . ( ) compoundstm

    (               shift and go to state 73


state 62

    (1) service -> SERVICE { htmls schemas variables functions sessions } .

    $end            reduce using rule 1 (service -> SERVICE { htmls schemas variables functions sessions } .)


state 63

    (51) function -> type IDENTIFIER ( . arguments ) compoundstm
    (52) arguments -> .
    (53) arguments -> . nearguments
    (54) nearguments -> . argument
    (55) nearguments -> . argument , nearguments
    (56) argument -> . type IDENTIFIER
    (45) type -> . simpletype
    (46) type -> . TUPLE IDENTIFIER
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

    )               reduce using rule 52 (arguments -> .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    simpletype                     shift and go to state 16
    nearguments                    shift and go to state 74
    type                           shift and go to state 77
    argument                       shift and go to state 75
    arguments                      shift and go to state 76

state 64

    (10) htmlbody -> START_HOLE IDENTIFIER . END_HOLE

    END_HOLE        shift and go to state 78


state 65

    (9) htmlbody -> START_CLOSE_TAG IDENTIFIER . END_TAG

    END_TAG         shift and go to state 79


state 66

    (13) htmlbody -> START_TAG INPUT . attributes END_TAG
    (16) attributes -> .
    (17) attributes -> . neattributes
    (18) neattributes -> . attribute
    (19) neattributes -> . attribute neattributes
    (20) attribute -> . attr
    (21) attribute -> . attr = attr
    (22) attr -> . IDENTIFIER
    (23) attr -> . STRING_LITERAL

    END_TAG         reduce using rule 16 (attributes -> .)
    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    neattributes                   shift and go to state 83
    attributes                     shift and go to state 82
    attr                           shift and go to state 80
    attribute                      shift and go to state 81

state 67

    (8) htmlbody -> START_TAG IDENTIFIER . attributes END_TAG
    (16) attributes -> .
    (17) attributes -> . neattributes
    (18) neattributes -> . attribute
    (19) neattributes -> . attribute neattributes
    (20) attribute -> . attr
    (21) attribute -> . attr = attr
    (22) attr -> . IDENTIFIER
    (23) attr -> . STRING_LITERAL

    END_TAG         reduce using rule 16 (attributes -> .)
    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    neattributes                   shift and go to state 83
    attributes                     shift and go to state 86
    attr                           shift and go to state 80
    attribute                      shift and go to state 81

state 68

    (14) htmlbody -> START_TAG SELECT . attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (15) htmlbody -> START_TAG SELECT . attributes END_TAG START_CLOSE_TAG SELECT END_TAG
    (16) attributes -> .
    (17) attributes -> . neattributes
    (18) neattributes -> . attribute
    (19) neattributes -> . attribute neattributes
    (20) attribute -> . attr
    (21) attribute -> . attr = attr
    (22) attr -> . IDENTIFIER
    (23) attr -> . STRING_LITERAL

    END_TAG         reduce using rule 16 (attributes -> .)
    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    neattributes                   shift and go to state 83
    attributes                     shift and go to state 87
    attr                           shift and go to state 80
    attribute                      shift and go to state 81

state 69

    (7) nehtmlbodies -> htmlbody nehtmlbodies .

    END_HTML_LITERAL reduce using rule 7 (nehtmlbodies -> htmlbody nehtmlbodies .)
    START_CLOSE_TAG reduce using rule 7 (nehtmlbodies -> htmlbody nehtmlbodies .)


state 70

    (5) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .

    CONST           reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    SCHEMA          reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    TUPLE           reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    INT             reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    BOOL            reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    STRING          reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    VOID            reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)
    SESSION         reduce using rule 5 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL END_HTML_LITERAL ; .)


state 71

    (4) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL . ;

    ;               shift and go to state 88


state 72

    (33) field -> simpletype IDENTIFIER ; .

    INT             reduce using rule 33 (field -> simpletype IDENTIFIER ; .)
    BOOL            reduce using rule 33 (field -> simpletype IDENTIFIER ; .)
    STRING          reduce using rule 33 (field -> simpletype IDENTIFIER ; .)
    VOID            reduce using rule 33 (field -> simpletype IDENTIFIER ; .)
    }               reduce using rule 33 (field -> simpletype IDENTIFIER ; .)


state 73

    (59) session -> SESSION IDENTIFIER ( . ) compoundstm

    )               shift and go to state 89


state 74

    (53) arguments -> nearguments .

    )               reduce using rule 53 (arguments -> nearguments .)


state 75

    (54) nearguments -> argument .
    (55) nearguments -> argument . , nearguments

    )               reduce using rule 54 (nearguments -> argument .)
    ,               shift and go to state 90


state 76

    (51) function -> type IDENTIFIER ( arguments . ) compoundstm

    )               shift and go to state 91


state 77

    (56) argument -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 92


state 78

    (10) htmlbody -> START_HOLE IDENTIFIER END_HOLE .

    START_TAG       reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    START_CLOSE_TAG reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    START_HOLE      reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    WHATEVER        reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    META            reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)
    END_HTML_LITERAL reduce using rule 10 (htmlbody -> START_HOLE IDENTIFIER END_HOLE .)


state 79

    (9) htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .

    START_TAG       reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    START_CLOSE_TAG reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    START_HOLE      reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    WHATEVER        reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    META            reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)
    END_HTML_LITERAL reduce using rule 9 (htmlbody -> START_CLOSE_TAG IDENTIFIER END_TAG .)


state 80

    (20) attribute -> attr .
    (21) attribute -> attr . = attr

    IDENTIFIER      reduce using rule 20 (attribute -> attr .)
    STRING_LITERAL  reduce using rule 20 (attribute -> attr .)
    END_TAG         reduce using rule 20 (attribute -> attr .)
    =               shift and go to state 93


state 81

    (18) neattributes -> attribute .
    (19) neattributes -> attribute . neattributes
    (18) neattributes -> . attribute
    (19) neattributes -> . attribute neattributes
    (20) attribute -> . attr
    (21) attribute -> . attr = attr
    (22) attr -> . IDENTIFIER
    (23) attr -> . STRING_LITERAL

    END_TAG         reduce using rule 18 (neattributes -> attribute .)
    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    neattributes                   shift and go to state 94
    attribute                      shift and go to state 81
    attr                           shift and go to state 80

state 82

    (13) htmlbody -> START_TAG INPUT attributes . END_TAG

    END_TAG         shift and go to state 95


state 83

    (17) attributes -> neattributes .

    END_TAG         reduce using rule 17 (attributes -> neattributes .)


state 84

    (22) attr -> IDENTIFIER .

    =               reduce using rule 22 (attr -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 22 (attr -> IDENTIFIER .)
    STRING_LITERAL  reduce using rule 22 (attr -> IDENTIFIER .)
    END_TAG         reduce using rule 22 (attr -> IDENTIFIER .)


state 85

    (23) attr -> STRING_LITERAL .

    =               reduce using rule 23 (attr -> STRING_LITERAL .)
    IDENTIFIER      reduce using rule 23 (attr -> STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 23 (attr -> STRING_LITERAL .)
    END_TAG         reduce using rule 23 (attr -> STRING_LITERAL .)


state 86

    (8) htmlbody -> START_TAG IDENTIFIER attributes . END_TAG

    END_TAG         shift and go to state 96


state 87

    (14) htmlbody -> START_TAG SELECT attributes . END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (15) htmlbody -> START_TAG SELECT attributes . END_TAG START_CLOSE_TAG SELECT END_TAG

    END_TAG         shift and go to state 97


state 88

    (4) html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .

    CONST           reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    SCHEMA          reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    TUPLE           reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    INT             reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    BOOL            reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    STRING          reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    VOID            reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)
    SESSION         reduce using rule 4 (html -> CONST HTML IDENTIFIER = START_HTML_LITERAL nehtmlbodies END_HTML_LITERAL ; .)


state 89

    (59) session -> SESSION IDENTIFIER ( ) . compoundstm
    (78) compoundstm -> . { variables stms }

    {               shift and go to state 98

    compoundstm                    shift and go to state 99

state 90

    (55) nearguments -> argument , . nearguments
    (54) nearguments -> . argument
    (55) nearguments -> . argument , nearguments
    (56) argument -> . type IDENTIFIER
    (45) type -> . simpletype
    (46) type -> . TUPLE IDENTIFIER
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

    simpletype                     shift and go to state 16
    type                           shift and go to state 77
    argument                       shift and go to state 75
    nearguments                    shift and go to state 100

state 91

    (51) function -> type IDENTIFIER ( arguments ) . compoundstm
    (78) compoundstm -> . { variables stms }

    {               shift and go to state 98

    compoundstm                    shift and go to state 101

state 92

    (56) argument -> type IDENTIFIER .

    ,               reduce using rule 56 (argument -> type IDENTIFIER .)
    )               reduce using rule 56 (argument -> type IDENTIFIER .)


state 93

    (21) attribute -> attr = . attr
    (22) attr -> . IDENTIFIER
    (23) attr -> . STRING_LITERAL

    IDENTIFIER      shift and go to state 84
    STRING_LITERAL  shift and go to state 85

    attr                           shift and go to state 102

state 94

    (19) neattributes -> attribute neattributes .

    END_TAG         reduce using rule 19 (neattributes -> attribute neattributes .)


state 95

    (13) htmlbody -> START_TAG INPUT attributes END_TAG .

    START_TAG       reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    START_CLOSE_TAG reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    START_HOLE      reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    WHATEVER        reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    META            reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)
    END_HTML_LITERAL reduce using rule 13 (htmlbody -> START_TAG INPUT attributes END_TAG .)


state 96

    (8) htmlbody -> START_TAG IDENTIFIER attributes END_TAG .

    START_TAG       reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    START_CLOSE_TAG reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    START_HOLE      reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    WHATEVER        reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    META            reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)
    END_HTML_LITERAL reduce using rule 8 (htmlbody -> START_TAG IDENTIFIER attributes END_TAG .)


state 97

    (14) htmlbody -> START_TAG SELECT attributes END_TAG . nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (15) htmlbody -> START_TAG SELECT attributes END_TAG . START_CLOSE_TAG SELECT END_TAG
    (6) nehtmlbodies -> . htmlbody
    (7) nehtmlbodies -> . htmlbody nehtmlbodies
    (8) htmlbody -> . START_TAG IDENTIFIER attributes END_TAG
    (9) htmlbody -> . START_CLOSE_TAG IDENTIFIER END_TAG
    (10) htmlbody -> . START_HOLE IDENTIFIER END_HOLE
    (11) htmlbody -> . WHATEVER
    (12) htmlbody -> . META
    (13) htmlbody -> . START_TAG INPUT attributes END_TAG
    (14) htmlbody -> . START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG
    (15) htmlbody -> . START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG

    START_CLOSE_TAG shift and go to state 103
    START_TAG       shift and go to state 50
    START_HOLE      shift and go to state 48
    WHATEVER        shift and go to state 51
    META            shift and go to state 53

    nehtmlbodies                   shift and go to state 104
    htmlbody                       shift and go to state 52

state 98

    (78) compoundstm -> { . variables stms }
    (34) variables -> .
    (35) variables -> . nevariables
    (36) nevariables -> . variable
    (37) nevariables -> . variable nevariables
    (38) variable -> . type identifiers ;
    (45) type -> . simpletype
    (46) type -> . TUPLE IDENTIFIER
    (41) simpletype -> . INT
    (42) simpletype -> . BOOL
    (43) simpletype -> . STRING
    (44) simpletype -> . VOID

  ! shift/reduce conflict for TUPLE resolved as shift
    ;               reduce using rule 34 (variables -> .)
    SHOW            reduce using rule 34 (variables -> .)
    EXIT            reduce using rule 34 (variables -> .)
    RETURN          reduce using rule 34 (variables -> .)
    IF              reduce using rule 34 (variables -> .)
    WHILE           reduce using rule 34 (variables -> .)
    {               reduce using rule 34 (variables -> .)
    -               reduce using rule 34 (variables -> .)
    !               reduce using rule 34 (variables -> .)
    IDENTIFIER      reduce using rule 34 (variables -> .)
    STRING_LITERAL  reduce using rule 34 (variables -> .)
    TRUE            reduce using rule 34 (variables -> .)
    FALSE           reduce using rule 34 (variables -> .)
    INT_LITERAL     reduce using rule 34 (variables -> .)
    (               reduce using rule 34 (variables -> .)
    }               reduce using rule 34 (variables -> .)
    TUPLE           shift and go to state 21
    INT             shift and go to state 18
    BOOL            shift and go to state 23
    STRING          shift and go to state 24
    VOID            shift and go to state 22

  ! TUPLE           [ reduce using rule 34 (variables -> .) ]

    simpletype                     shift and go to state 16
    nevariables                    shift and go to state 17
    variables                      shift and go to state 105
    variable                       shift and go to state 25
    type                           shift and go to state 19

state 99

    (59) session -> SESSION IDENTIFIER ( ) compoundstm .

    SESSION         reduce using rule 59 (session -> SESSION IDENTIFIER ( ) compoundstm .)
    }               reduce using rule 59 (session -> SESSION IDENTIFIER ( ) compoundstm .)


state 100

    (55) nearguments -> argument , nearguments .

    )               reduce using rule 55 (nearguments -> argument , nearguments .)


state 101

    (51) function -> type IDENTIFIER ( arguments ) compoundstm .

    TUPLE           reduce using rule 51 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    INT             reduce using rule 51 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    BOOL            reduce using rule 51 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    STRING          reduce using rule 51 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    VOID            reduce using rule 51 (function -> type IDENTIFIER ( arguments ) compoundstm .)
    SESSION         reduce using rule 51 (function -> type IDENTIFIER ( arguments ) compoundstm .)


state 102

    (21) attribute -> attr = attr .

    IDENTIFIER      reduce using rule 21 (attribute -> attr = attr .)
    STRING_LITERAL  reduce using rule 21 (attribute -> attr = attr .)
    END_TAG         reduce using rule 21 (attribute -> attr = attr .)


state 103

    (15) htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG . SELECT END_TAG
    (9) htmlbody -> START_CLOSE_TAG . IDENTIFIER END_TAG

    SELECT          shift and go to state 106
    IDENTIFIER      shift and go to state 65


state 104

    (14) htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies . START_CLOSE_TAG SELECT END_TAG

    START_CLOSE_TAG shift and go to state 107


state 105

    (78) compoundstm -> { variables . stms }
    (60) stms -> .
    (61) stms -> . nestms
    (62) nestms -> . stm
    (63) nestms -> . stm nestms
    (64) stm -> . ;
    (65) stm -> . SHOW document receive ;
    (66) stm -> . EXIT document ;
    (67) stm -> . RETURN ;
    (68) stm -> . RETURN exp ;
    (69) stm -> . IF ( exp ) stm
    (70) stm -> . IF ( exp ) stm ELSE stm
    (71) stm -> . WHILE ( exp ) stm
    (72) stm -> . compoundstm
    (73) stm -> . exp ;
    (78) compoundstm -> . { variables stms }
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    }               reduce using rule 60 (stms -> .)
    ;               shift and go to state 114
    SHOW            shift and go to state 116
    EXIT            shift and go to state 125
    RETURN          shift and go to state 108
    IF              shift and go to state 119
    WHILE           shift and go to state 109
    {               shift and go to state 98
    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    nestms                         shift and go to state 111
    lvalue                         shift and go to state 112
    stms                           shift and go to state 117
    exp                            shift and go to state 126
    stm                            shift and go to state 124
    compoundstm                    shift and go to state 110

state 106

    (15) htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT . END_TAG

    END_TAG         shift and go to state 129


state 107

    (14) htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG . SELECT END_TAG

    SELECT          shift and go to state 130


state 108

    (67) stm -> RETURN . ;
    (68) stm -> RETURN . exp ;
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    ;               shift and go to state 131
    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 132

state 109

    (71) stm -> WHILE . ( exp ) stm

    (               shift and go to state 133


state 110

    (72) stm -> compoundstm .

    ;               reduce using rule 72 (stm -> compoundstm .)
    SHOW            reduce using rule 72 (stm -> compoundstm .)
    EXIT            reduce using rule 72 (stm -> compoundstm .)
    RETURN          reduce using rule 72 (stm -> compoundstm .)
    IF              reduce using rule 72 (stm -> compoundstm .)
    WHILE           reduce using rule 72 (stm -> compoundstm .)
    {               reduce using rule 72 (stm -> compoundstm .)
    -               reduce using rule 72 (stm -> compoundstm .)
    !               reduce using rule 72 (stm -> compoundstm .)
    IDENTIFIER      reduce using rule 72 (stm -> compoundstm .)
    STRING_LITERAL  reduce using rule 72 (stm -> compoundstm .)
    TRUE            reduce using rule 72 (stm -> compoundstm .)
    FALSE           reduce using rule 72 (stm -> compoundstm .)
    INT_LITERAL     reduce using rule 72 (stm -> compoundstm .)
    TUPLE           reduce using rule 72 (stm -> compoundstm .)
    (               reduce using rule 72 (stm -> compoundstm .)
    }               reduce using rule 72 (stm -> compoundstm .)
    ELSE            reduce using rule 72 (stm -> compoundstm .)


state 111

    (61) stms -> nestms .

    }               reduce using rule 61 (stms -> nestms .)


state 112

    (87) exp -> lvalue . = exp
    (108) exp -> lvalue .

    =               shift and go to state 134
    EQ              reduce using rule 108 (exp -> lvalue .)
    NEQ             reduce using rule 108 (exp -> lvalue .)
    <               reduce using rule 108 (exp -> lvalue .)
    >               reduce using rule 108 (exp -> lvalue .)
    LTEQ            reduce using rule 108 (exp -> lvalue .)
    GTEQ            reduce using rule 108 (exp -> lvalue .)
    +               reduce using rule 108 (exp -> lvalue .)
    -               reduce using rule 108 (exp -> lvalue .)
    *               reduce using rule 108 (exp -> lvalue .)
    /               reduce using rule 108 (exp -> lvalue .)
    %               reduce using rule 108 (exp -> lvalue .)
    AND             reduce using rule 108 (exp -> lvalue .)
    OR              reduce using rule 108 (exp -> lvalue .)
    LSHIFT          reduce using rule 108 (exp -> lvalue .)
    TADD            reduce using rule 108 (exp -> lvalue .)
    TSUB            reduce using rule 108 (exp -> lvalue .)
    ;               reduce using rule 108 (exp -> lvalue .)
    )               reduce using rule 108 (exp -> lvalue .)
    ,               reduce using rule 108 (exp -> lvalue .)
    }               reduce using rule 108 (exp -> lvalue .)
    ]               reduce using rule 108 (exp -> lvalue .)


state 113

    (106) exp -> - . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 135

state 114

    (64) stm -> ; .

    ;               reduce using rule 64 (stm -> ; .)
    SHOW            reduce using rule 64 (stm -> ; .)
    EXIT            reduce using rule 64 (stm -> ; .)
    RETURN          reduce using rule 64 (stm -> ; .)
    IF              reduce using rule 64 (stm -> ; .)
    WHILE           reduce using rule 64 (stm -> ; .)
    {               reduce using rule 64 (stm -> ; .)
    -               reduce using rule 64 (stm -> ; .)
    !               reduce using rule 64 (stm -> ; .)
    IDENTIFIER      reduce using rule 64 (stm -> ; .)
    STRING_LITERAL  reduce using rule 64 (stm -> ; .)
    TRUE            reduce using rule 64 (stm -> ; .)
    FALSE           reduce using rule 64 (stm -> ; .)
    INT_LITERAL     reduce using rule 64 (stm -> ; .)
    TUPLE           reduce using rule 64 (stm -> ; .)
    (               reduce using rule 64 (stm -> ; .)
    }               reduce using rule 64 (stm -> ; .)
    ELSE            reduce using rule 64 (stm -> ; .)


state 115

    (107) exp -> ! . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 136

state 116

    (65) stm -> SHOW . document receive ;
    (74) document -> . IDENTIFIER
    (75) document -> . PLUG IDENTIFIER [ plugs ]

    IDENTIFIER      shift and go to state 139
    PLUG            shift and go to state 137

    document                       shift and go to state 138

state 117

    (78) compoundstm -> { variables stms . }

    }               shift and go to state 140


state 118

    (111) exp -> TRUE .

    EQ              reduce using rule 111 (exp -> TRUE .)
    NEQ             reduce using rule 111 (exp -> TRUE .)
    <               reduce using rule 111 (exp -> TRUE .)
    >               reduce using rule 111 (exp -> TRUE .)
    LTEQ            reduce using rule 111 (exp -> TRUE .)
    GTEQ            reduce using rule 111 (exp -> TRUE .)
    +               reduce using rule 111 (exp -> TRUE .)
    -               reduce using rule 111 (exp -> TRUE .)
    *               reduce using rule 111 (exp -> TRUE .)
    /               reduce using rule 111 (exp -> TRUE .)
    %               reduce using rule 111 (exp -> TRUE .)
    AND             reduce using rule 111 (exp -> TRUE .)
    OR              reduce using rule 111 (exp -> TRUE .)
    LSHIFT          reduce using rule 111 (exp -> TRUE .)
    TADD            reduce using rule 111 (exp -> TRUE .)
    TSUB            reduce using rule 111 (exp -> TRUE .)
    ;               reduce using rule 111 (exp -> TRUE .)
    )               reduce using rule 111 (exp -> TRUE .)
    ,               reduce using rule 111 (exp -> TRUE .)
    }               reduce using rule 111 (exp -> TRUE .)
    ]               reduce using rule 111 (exp -> TRUE .)


state 119

    (69) stm -> IF . ( exp ) stm
    (70) stm -> IF . ( exp ) stm ELSE stm

    (               shift and go to state 141


state 120

    (109) exp -> IDENTIFIER . ( exps )
    (120) lvalue -> IDENTIFIER .
    (121) lvalue -> IDENTIFIER . . IDENTIFIER

    (               shift and go to state 142
    =               reduce using rule 120 (lvalue -> IDENTIFIER .)
    EQ              reduce using rule 120 (lvalue -> IDENTIFIER .)
    NEQ             reduce using rule 120 (lvalue -> IDENTIFIER .)
    <               reduce using rule 120 (lvalue -> IDENTIFIER .)
    >               reduce using rule 120 (lvalue -> IDENTIFIER .)
    LTEQ            reduce using rule 120 (lvalue -> IDENTIFIER .)
    GTEQ            reduce using rule 120 (lvalue -> IDENTIFIER .)
    +               reduce using rule 120 (lvalue -> IDENTIFIER .)
    -               reduce using rule 120 (lvalue -> IDENTIFIER .)
    *               reduce using rule 120 (lvalue -> IDENTIFIER .)
    /               reduce using rule 120 (lvalue -> IDENTIFIER .)
    %               reduce using rule 120 (lvalue -> IDENTIFIER .)
    AND             reduce using rule 120 (lvalue -> IDENTIFIER .)
    OR              reduce using rule 120 (lvalue -> IDENTIFIER .)
    LSHIFT          reduce using rule 120 (lvalue -> IDENTIFIER .)
    TADD            reduce using rule 120 (lvalue -> IDENTIFIER .)
    TSUB            reduce using rule 120 (lvalue -> IDENTIFIER .)
    ;               reduce using rule 120 (lvalue -> IDENTIFIER .)
    )               reduce using rule 120 (lvalue -> IDENTIFIER .)
    ,               reduce using rule 120 (lvalue -> IDENTIFIER .)
    }               reduce using rule 120 (lvalue -> IDENTIFIER .)
    ]               reduce using rule 120 (lvalue -> IDENTIFIER .)
    .               shift and go to state 143


state 121

    (112) exp -> FALSE .

    EQ              reduce using rule 112 (exp -> FALSE .)
    NEQ             reduce using rule 112 (exp -> FALSE .)
    <               reduce using rule 112 (exp -> FALSE .)
    >               reduce using rule 112 (exp -> FALSE .)
    LTEQ            reduce using rule 112 (exp -> FALSE .)
    GTEQ            reduce using rule 112 (exp -> FALSE .)
    +               reduce using rule 112 (exp -> FALSE .)
    -               reduce using rule 112 (exp -> FALSE .)
    *               reduce using rule 112 (exp -> FALSE .)
    /               reduce using rule 112 (exp -> FALSE .)
    %               reduce using rule 112 (exp -> FALSE .)
    AND             reduce using rule 112 (exp -> FALSE .)
    OR              reduce using rule 112 (exp -> FALSE .)
    LSHIFT          reduce using rule 112 (exp -> FALSE .)
    TADD            reduce using rule 112 (exp -> FALSE .)
    TSUB            reduce using rule 112 (exp -> FALSE .)
    ;               reduce using rule 112 (exp -> FALSE .)
    )               reduce using rule 112 (exp -> FALSE .)
    ,               reduce using rule 112 (exp -> FALSE .)
    }               reduce using rule 112 (exp -> FALSE .)
    ]               reduce using rule 112 (exp -> FALSE .)


state 122

    (110) exp -> STRING_LITERAL .

    EQ              reduce using rule 110 (exp -> STRING_LITERAL .)
    NEQ             reduce using rule 110 (exp -> STRING_LITERAL .)
    <               reduce using rule 110 (exp -> STRING_LITERAL .)
    >               reduce using rule 110 (exp -> STRING_LITERAL .)
    LTEQ            reduce using rule 110 (exp -> STRING_LITERAL .)
    GTEQ            reduce using rule 110 (exp -> STRING_LITERAL .)
    +               reduce using rule 110 (exp -> STRING_LITERAL .)
    -               reduce using rule 110 (exp -> STRING_LITERAL .)
    *               reduce using rule 110 (exp -> STRING_LITERAL .)
    /               reduce using rule 110 (exp -> STRING_LITERAL .)
    %               reduce using rule 110 (exp -> STRING_LITERAL .)
    AND             reduce using rule 110 (exp -> STRING_LITERAL .)
    OR              reduce using rule 110 (exp -> STRING_LITERAL .)
    LSHIFT          reduce using rule 110 (exp -> STRING_LITERAL .)
    TADD            reduce using rule 110 (exp -> STRING_LITERAL .)
    TSUB            reduce using rule 110 (exp -> STRING_LITERAL .)
    ;               reduce using rule 110 (exp -> STRING_LITERAL .)
    )               reduce using rule 110 (exp -> STRING_LITERAL .)
    ,               reduce using rule 110 (exp -> STRING_LITERAL .)
    }               reduce using rule 110 (exp -> STRING_LITERAL .)
    ]               reduce using rule 110 (exp -> STRING_LITERAL .)


state 123

    (114) exp -> TUPLE . { fieldvalues }

    {               shift and go to state 144


state 124

    (62) nestms -> stm .
    (63) nestms -> stm . nestms
    (62) nestms -> . stm
    (63) nestms -> . stm nestms
    (64) stm -> . ;
    (65) stm -> . SHOW document receive ;
    (66) stm -> . EXIT document ;
    (67) stm -> . RETURN ;
    (68) stm -> . RETURN exp ;
    (69) stm -> . IF ( exp ) stm
    (70) stm -> . IF ( exp ) stm ELSE stm
    (71) stm -> . WHILE ( exp ) stm
    (72) stm -> . compoundstm
    (73) stm -> . exp ;
    (78) compoundstm -> . { variables stms }
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    }               reduce using rule 62 (nestms -> stm .)
    ;               shift and go to state 114
    SHOW            shift and go to state 116
    EXIT            shift and go to state 125
    RETURN          shift and go to state 108
    IF              shift and go to state 119
    WHILE           shift and go to state 109
    {               shift and go to state 98
    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    nestms                         shift and go to state 145
    lvalue                         shift and go to state 112
    stm                            shift and go to state 124
    exp                            shift and go to state 126
    compoundstm                    shift and go to state 110

state 125

    (66) stm -> EXIT . document ;
    (74) document -> . IDENTIFIER
    (75) document -> . PLUG IDENTIFIER [ plugs ]

    IDENTIFIER      shift and go to state 139
    PLUG            shift and go to state 137

    document                       shift and go to state 146

state 126

    (73) stm -> exp . ;
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    ;               shift and go to state 157
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163
    LSHIFT          shift and go to state 149
    TADD            shift and go to state 150
    TSUB            shift and go to state 148


state 127

    (115) exp -> ( . exp )
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 164

state 128

    (113) exp -> INT_LITERAL .

    EQ              reduce using rule 113 (exp -> INT_LITERAL .)
    NEQ             reduce using rule 113 (exp -> INT_LITERAL .)
    <               reduce using rule 113 (exp -> INT_LITERAL .)
    >               reduce using rule 113 (exp -> INT_LITERAL .)
    LTEQ            reduce using rule 113 (exp -> INT_LITERAL .)
    GTEQ            reduce using rule 113 (exp -> INT_LITERAL .)
    +               reduce using rule 113 (exp -> INT_LITERAL .)
    -               reduce using rule 113 (exp -> INT_LITERAL .)
    *               reduce using rule 113 (exp -> INT_LITERAL .)
    /               reduce using rule 113 (exp -> INT_LITERAL .)
    %               reduce using rule 113 (exp -> INT_LITERAL .)
    AND             reduce using rule 113 (exp -> INT_LITERAL .)
    OR              reduce using rule 113 (exp -> INT_LITERAL .)
    LSHIFT          reduce using rule 113 (exp -> INT_LITERAL .)
    TADD            reduce using rule 113 (exp -> INT_LITERAL .)
    TSUB            reduce using rule 113 (exp -> INT_LITERAL .)
    ;               reduce using rule 113 (exp -> INT_LITERAL .)
    )               reduce using rule 113 (exp -> INT_LITERAL .)
    ,               reduce using rule 113 (exp -> INT_LITERAL .)
    }               reduce using rule 113 (exp -> INT_LITERAL .)
    ]               reduce using rule 113 (exp -> INT_LITERAL .)


state 129

    (15) htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG .

    START_TAG       reduce using rule 15 (htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG .)
    START_CLOSE_TAG reduce using rule 15 (htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG .)
    START_HOLE      reduce using rule 15 (htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG .)
    WHATEVER        reduce using rule 15 (htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG .)
    META            reduce using rule 15 (htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG .)
    END_HTML_LITERAL reduce using rule 15 (htmlbody -> START_TAG SELECT attributes END_TAG START_CLOSE_TAG SELECT END_TAG .)


state 130

    (14) htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT . END_TAG

    END_TAG         shift and go to state 165


state 131

    (67) stm -> RETURN ; .

    ;               reduce using rule 67 (stm -> RETURN ; .)
    SHOW            reduce using rule 67 (stm -> RETURN ; .)
    EXIT            reduce using rule 67 (stm -> RETURN ; .)
    RETURN          reduce using rule 67 (stm -> RETURN ; .)
    IF              reduce using rule 67 (stm -> RETURN ; .)
    WHILE           reduce using rule 67 (stm -> RETURN ; .)
    {               reduce using rule 67 (stm -> RETURN ; .)
    -               reduce using rule 67 (stm -> RETURN ; .)
    !               reduce using rule 67 (stm -> RETURN ; .)
    IDENTIFIER      reduce using rule 67 (stm -> RETURN ; .)
    STRING_LITERAL  reduce using rule 67 (stm -> RETURN ; .)
    TRUE            reduce using rule 67 (stm -> RETURN ; .)
    FALSE           reduce using rule 67 (stm -> RETURN ; .)
    INT_LITERAL     reduce using rule 67 (stm -> RETURN ; .)
    TUPLE           reduce using rule 67 (stm -> RETURN ; .)
    (               reduce using rule 67 (stm -> RETURN ; .)
    }               reduce using rule 67 (stm -> RETURN ; .)
    ELSE            reduce using rule 67 (stm -> RETURN ; .)


state 132

    (68) stm -> RETURN exp . ;
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    ;               shift and go to state 166
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163
    LSHIFT          shift and go to state 149
    TADD            shift and go to state 150
    TSUB            shift and go to state 148


state 133

    (71) stm -> WHILE ( . exp ) stm
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    exp                            shift and go to state 167
    lvalue                         shift and go to state 112

state 134

    (87) exp -> lvalue = . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 168

state 135

    (106) exp -> - exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 106 (exp -> - exp .)
    NEQ             reduce using rule 106 (exp -> - exp .)
    <               reduce using rule 106 (exp -> - exp .)
    >               reduce using rule 106 (exp -> - exp .)
    LTEQ            reduce using rule 106 (exp -> - exp .)
    GTEQ            reduce using rule 106 (exp -> - exp .)
    +               reduce using rule 106 (exp -> - exp .)
    -               reduce using rule 106 (exp -> - exp .)
    *               reduce using rule 106 (exp -> - exp .)
    /               reduce using rule 106 (exp -> - exp .)
    %               reduce using rule 106 (exp -> - exp .)
    AND             reduce using rule 106 (exp -> - exp .)
    OR              reduce using rule 106 (exp -> - exp .)
    LSHIFT          reduce using rule 106 (exp -> - exp .)
    TADD            reduce using rule 106 (exp -> - exp .)
    TSUB            reduce using rule 106 (exp -> - exp .)
    ;               reduce using rule 106 (exp -> - exp .)
    )               reduce using rule 106 (exp -> - exp .)
    ,               reduce using rule 106 (exp -> - exp .)
    }               reduce using rule 106 (exp -> - exp .)
    ]               reduce using rule 106 (exp -> - exp .)

  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! +               [ shift and go to state 153 ]
  ! -               [ shift and go to state 155 ]
  ! *               [ shift and go to state 154 ]
  ! /               [ shift and go to state 156 ]
  ! %               [ shift and go to state 152 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 136

    (107) exp -> ! exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 107 (exp -> ! exp .)
    NEQ             reduce using rule 107 (exp -> ! exp .)
    <               reduce using rule 107 (exp -> ! exp .)
    >               reduce using rule 107 (exp -> ! exp .)
    LTEQ            reduce using rule 107 (exp -> ! exp .)
    GTEQ            reduce using rule 107 (exp -> ! exp .)
    +               reduce using rule 107 (exp -> ! exp .)
    -               reduce using rule 107 (exp -> ! exp .)
    *               reduce using rule 107 (exp -> ! exp .)
    /               reduce using rule 107 (exp -> ! exp .)
    %               reduce using rule 107 (exp -> ! exp .)
    AND             reduce using rule 107 (exp -> ! exp .)
    OR              reduce using rule 107 (exp -> ! exp .)
    LSHIFT          reduce using rule 107 (exp -> ! exp .)
    TADD            reduce using rule 107 (exp -> ! exp .)
    TSUB            reduce using rule 107 (exp -> ! exp .)
    ;               reduce using rule 107 (exp -> ! exp .)
    )               reduce using rule 107 (exp -> ! exp .)
    ,               reduce using rule 107 (exp -> ! exp .)
    }               reduce using rule 107 (exp -> ! exp .)
    ]               reduce using rule 107 (exp -> ! exp .)

  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! +               [ shift and go to state 153 ]
  ! -               [ shift and go to state 155 ]
  ! *               [ shift and go to state 154 ]
  ! /               [ shift and go to state 156 ]
  ! %               [ shift and go to state 152 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 137

    (75) document -> PLUG . IDENTIFIER [ plugs ]

    IDENTIFIER      shift and go to state 169


state 138

    (65) stm -> SHOW document . receive ;
    (76) receive -> .
    (77) receive -> . RECEIVE [ inputs ]

    ;               reduce using rule 76 (receive -> .)
    RECEIVE         shift and go to state 171

    receive                        shift and go to state 170

state 139

    (74) document -> IDENTIFIER .

    RECEIVE         reduce using rule 74 (document -> IDENTIFIER .)
    ;               reduce using rule 74 (document -> IDENTIFIER .)


state 140

    (78) compoundstm -> { variables stms } .

    ;               reduce using rule 78 (compoundstm -> { variables stms } .)
    SHOW            reduce using rule 78 (compoundstm -> { variables stms } .)
    EXIT            reduce using rule 78 (compoundstm -> { variables stms } .)
    RETURN          reduce using rule 78 (compoundstm -> { variables stms } .)
    IF              reduce using rule 78 (compoundstm -> { variables stms } .)
    WHILE           reduce using rule 78 (compoundstm -> { variables stms } .)
    {               reduce using rule 78 (compoundstm -> { variables stms } .)
    -               reduce using rule 78 (compoundstm -> { variables stms } .)
    !               reduce using rule 78 (compoundstm -> { variables stms } .)
    IDENTIFIER      reduce using rule 78 (compoundstm -> { variables stms } .)
    STRING_LITERAL  reduce using rule 78 (compoundstm -> { variables stms } .)
    TRUE            reduce using rule 78 (compoundstm -> { variables stms } .)
    FALSE           reduce using rule 78 (compoundstm -> { variables stms } .)
    INT_LITERAL     reduce using rule 78 (compoundstm -> { variables stms } .)
    TUPLE           reduce using rule 78 (compoundstm -> { variables stms } .)
    (               reduce using rule 78 (compoundstm -> { variables stms } .)
    }               reduce using rule 78 (compoundstm -> { variables stms } .)
    ELSE            reduce using rule 78 (compoundstm -> { variables stms } .)
    SESSION         reduce using rule 78 (compoundstm -> { variables stms } .)
    INT             reduce using rule 78 (compoundstm -> { variables stms } .)
    BOOL            reduce using rule 78 (compoundstm -> { variables stms } .)
    STRING          reduce using rule 78 (compoundstm -> { variables stms } .)
    VOID            reduce using rule 78 (compoundstm -> { variables stms } .)


state 141

    (69) stm -> IF ( . exp ) stm
    (70) stm -> IF ( . exp ) stm ELSE stm
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    exp                            shift and go to state 172
    lvalue                         shift and go to state 112

state 142

    (109) exp -> IDENTIFIER ( . exps )
    (116) exps -> .
    (117) exps -> . neexps
    (118) neexps -> . exp
    (119) neexps -> . exp , neexps
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    )               reduce using rule 116 (exps -> .)
    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    neexps                         shift and go to state 173
    exps                           shift and go to state 174
    lvalue                         shift and go to state 112
    exp                            shift and go to state 175

state 143

    (121) lvalue -> IDENTIFIER . . IDENTIFIER

    IDENTIFIER      shift and go to state 176


state 144

    (114) exp -> TUPLE { . fieldvalues }
    (122) fieldvalues -> .
    (123) fieldvalues -> . nefieldvalues
    (124) nefieldvalues -> . fieldvalue
    (125) nefieldvalues -> . fieldvalue , fieldvalues
    (126) fieldvalue -> . IDENTIFIER = exp

    }               reduce using rule 122 (fieldvalues -> .)
    IDENTIFIER      shift and go to state 179

    nefieldvalues                  shift and go to state 177
    fieldvalues                    shift and go to state 178
    fieldvalue                     shift and go to state 180

state 145

    (63) nestms -> stm nestms .

    }               reduce using rule 63 (nestms -> stm nestms .)


state 146

    (66) stm -> EXIT document . ;

    ;               shift and go to state 181


state 147

    (93) exp -> exp GTEQ . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 182

state 148

    (104) exp -> exp TSUB . IDENTIFIER
    (105) exp -> exp TSUB . ( identifiers )

    IDENTIFIER      shift and go to state 184
    (               shift and go to state 183


state 149

    (101) exp -> exp LSHIFT . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 185

state 150

    (102) exp -> exp TADD . IDENTIFIER
    (103) exp -> exp TADD . ( identifiers )

    IDENTIFIER      shift and go to state 187
    (               shift and go to state 186


state 151

    (89) exp -> exp NEQ . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 188

state 152

    (98) exp -> exp % . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 189

state 153

    (94) exp -> exp + . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 190

state 154

    (96) exp -> exp * . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 191

state 155

    (95) exp -> exp - . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 192

state 156

    (97) exp -> exp / . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 193

state 157

    (73) stm -> exp ; .

    ;               reduce using rule 73 (stm -> exp ; .)
    SHOW            reduce using rule 73 (stm -> exp ; .)
    EXIT            reduce using rule 73 (stm -> exp ; .)
    RETURN          reduce using rule 73 (stm -> exp ; .)
    IF              reduce using rule 73 (stm -> exp ; .)
    WHILE           reduce using rule 73 (stm -> exp ; .)
    {               reduce using rule 73 (stm -> exp ; .)
    -               reduce using rule 73 (stm -> exp ; .)
    !               reduce using rule 73 (stm -> exp ; .)
    IDENTIFIER      reduce using rule 73 (stm -> exp ; .)
    STRING_LITERAL  reduce using rule 73 (stm -> exp ; .)
    TRUE            reduce using rule 73 (stm -> exp ; .)
    FALSE           reduce using rule 73 (stm -> exp ; .)
    INT_LITERAL     reduce using rule 73 (stm -> exp ; .)
    TUPLE           reduce using rule 73 (stm -> exp ; .)
    (               reduce using rule 73 (stm -> exp ; .)
    }               reduce using rule 73 (stm -> exp ; .)
    ELSE            reduce using rule 73 (stm -> exp ; .)


state 158

    (90) exp -> exp < . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 194

state 159

    (91) exp -> exp > . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 195

state 160

    (88) exp -> exp EQ . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 196

state 161

    (99) exp -> exp AND . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 197

state 162

    (92) exp -> exp LTEQ . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 198

state 163

    (100) exp -> exp OR . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 199

state 164

    (115) exp -> ( exp . )
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    )               shift and go to state 200
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163
    LSHIFT          shift and go to state 149
    TADD            shift and go to state 150
    TSUB            shift and go to state 148


state 165

    (14) htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .

    START_TAG       reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    START_CLOSE_TAG reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    START_HOLE      reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    WHATEVER        reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    META            reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)
    END_HTML_LITERAL reduce using rule 14 (htmlbody -> START_TAG SELECT attributes END_TAG nehtmlbodies START_CLOSE_TAG SELECT END_TAG .)


state 166

    (68) stm -> RETURN exp ; .

    ;               reduce using rule 68 (stm -> RETURN exp ; .)
    SHOW            reduce using rule 68 (stm -> RETURN exp ; .)
    EXIT            reduce using rule 68 (stm -> RETURN exp ; .)
    RETURN          reduce using rule 68 (stm -> RETURN exp ; .)
    IF              reduce using rule 68 (stm -> RETURN exp ; .)
    WHILE           reduce using rule 68 (stm -> RETURN exp ; .)
    {               reduce using rule 68 (stm -> RETURN exp ; .)
    -               reduce using rule 68 (stm -> RETURN exp ; .)
    !               reduce using rule 68 (stm -> RETURN exp ; .)
    IDENTIFIER      reduce using rule 68 (stm -> RETURN exp ; .)
    STRING_LITERAL  reduce using rule 68 (stm -> RETURN exp ; .)
    TRUE            reduce using rule 68 (stm -> RETURN exp ; .)
    FALSE           reduce using rule 68 (stm -> RETURN exp ; .)
    INT_LITERAL     reduce using rule 68 (stm -> RETURN exp ; .)
    TUPLE           reduce using rule 68 (stm -> RETURN exp ; .)
    (               reduce using rule 68 (stm -> RETURN exp ; .)
    }               reduce using rule 68 (stm -> RETURN exp ; .)
    ELSE            reduce using rule 68 (stm -> RETURN exp ; .)


state 167

    (71) stm -> WHILE ( exp . ) stm
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    )               shift and go to state 201
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163
    LSHIFT          shift and go to state 149
    TADD            shift and go to state 150
    TSUB            shift and go to state 148


state 168

    (87) exp -> lvalue = exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 87 (exp -> lvalue = exp .)
    NEQ             reduce using rule 87 (exp -> lvalue = exp .)
    <               reduce using rule 87 (exp -> lvalue = exp .)
    >               reduce using rule 87 (exp -> lvalue = exp .)
    LTEQ            reduce using rule 87 (exp -> lvalue = exp .)
    GTEQ            reduce using rule 87 (exp -> lvalue = exp .)
    AND             reduce using rule 87 (exp -> lvalue = exp .)
    OR              reduce using rule 87 (exp -> lvalue = exp .)
    LSHIFT          reduce using rule 87 (exp -> lvalue = exp .)
    TADD            reduce using rule 87 (exp -> lvalue = exp .)
    TSUB            reduce using rule 87 (exp -> lvalue = exp .)
    ;               reduce using rule 87 (exp -> lvalue = exp .)
    )               reduce using rule 87 (exp -> lvalue = exp .)
    ,               reduce using rule 87 (exp -> lvalue = exp .)
    }               reduce using rule 87 (exp -> lvalue = exp .)
    ]               reduce using rule 87 (exp -> lvalue = exp .)
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! +               [ reduce using rule 87 (exp -> lvalue = exp .) ]
  ! -               [ reduce using rule 87 (exp -> lvalue = exp .) ]
  ! *               [ reduce using rule 87 (exp -> lvalue = exp .) ]
  ! /               [ reduce using rule 87 (exp -> lvalue = exp .) ]
  ! %               [ reduce using rule 87 (exp -> lvalue = exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 169

    (75) document -> PLUG IDENTIFIER . [ plugs ]

    [               shift and go to state 202


state 170

    (65) stm -> SHOW document receive . ;

    ;               shift and go to state 203


state 171

    (77) receive -> RECEIVE . [ inputs ]

    [               shift and go to state 204


state 172

    (69) stm -> IF ( exp . ) stm
    (70) stm -> IF ( exp . ) stm ELSE stm
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    )               shift and go to state 205
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163
    LSHIFT          shift and go to state 149
    TADD            shift and go to state 150
    TSUB            shift and go to state 148


state 173

    (117) exps -> neexps .

    )               reduce using rule 117 (exps -> neexps .)


state 174

    (109) exp -> IDENTIFIER ( exps . )

    )               shift and go to state 206


state 175

    (118) neexps -> exp .
    (119) neexps -> exp . , neexps
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    )               reduce using rule 118 (neexps -> exp .)
    ,               shift and go to state 207
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163
    LSHIFT          shift and go to state 149
    TADD            shift and go to state 150
    TSUB            shift and go to state 148


state 176

    (121) lvalue -> IDENTIFIER . IDENTIFIER .

    =               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    EQ              reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    NEQ             reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    <               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    >               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    LTEQ            reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    GTEQ            reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    +               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    -               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    *               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    /               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    %               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    AND             reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    OR              reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    LSHIFT          reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    TADD            reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    TSUB            reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    ;               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    )               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    ,               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    }               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)
    ]               reduce using rule 121 (lvalue -> IDENTIFIER . IDENTIFIER .)


state 177

    (123) fieldvalues -> nefieldvalues .

    }               reduce using rule 123 (fieldvalues -> nefieldvalues .)


state 178

    (114) exp -> TUPLE { fieldvalues . }

    }               shift and go to state 208


state 179

    (126) fieldvalue -> IDENTIFIER . = exp

    =               shift and go to state 209


state 180

    (124) nefieldvalues -> fieldvalue .
    (125) nefieldvalues -> fieldvalue . , fieldvalues

    }               reduce using rule 124 (nefieldvalues -> fieldvalue .)
    ,               shift and go to state 210


state 181

    (66) stm -> EXIT document ; .

    ;               reduce using rule 66 (stm -> EXIT document ; .)
    SHOW            reduce using rule 66 (stm -> EXIT document ; .)
    EXIT            reduce using rule 66 (stm -> EXIT document ; .)
    RETURN          reduce using rule 66 (stm -> EXIT document ; .)
    IF              reduce using rule 66 (stm -> EXIT document ; .)
    WHILE           reduce using rule 66 (stm -> EXIT document ; .)
    {               reduce using rule 66 (stm -> EXIT document ; .)
    -               reduce using rule 66 (stm -> EXIT document ; .)
    !               reduce using rule 66 (stm -> EXIT document ; .)
    IDENTIFIER      reduce using rule 66 (stm -> EXIT document ; .)
    STRING_LITERAL  reduce using rule 66 (stm -> EXIT document ; .)
    TRUE            reduce using rule 66 (stm -> EXIT document ; .)
    FALSE           reduce using rule 66 (stm -> EXIT document ; .)
    INT_LITERAL     reduce using rule 66 (stm -> EXIT document ; .)
    TUPLE           reduce using rule 66 (stm -> EXIT document ; .)
    (               reduce using rule 66 (stm -> EXIT document ; .)
    }               reduce using rule 66 (stm -> EXIT document ; .)
    ELSE            reduce using rule 66 (stm -> EXIT document ; .)


state 182

    (93) exp -> exp GTEQ exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 93 (exp -> exp GTEQ exp .)
    NEQ             reduce using rule 93 (exp -> exp GTEQ exp .)
    <               reduce using rule 93 (exp -> exp GTEQ exp .)
    >               reduce using rule 93 (exp -> exp GTEQ exp .)
    LTEQ            reduce using rule 93 (exp -> exp GTEQ exp .)
    GTEQ            reduce using rule 93 (exp -> exp GTEQ exp .)
    AND             reduce using rule 93 (exp -> exp GTEQ exp .)
    OR              reduce using rule 93 (exp -> exp GTEQ exp .)
    LSHIFT          reduce using rule 93 (exp -> exp GTEQ exp .)
    TADD            reduce using rule 93 (exp -> exp GTEQ exp .)
    TSUB            reduce using rule 93 (exp -> exp GTEQ exp .)
    ;               reduce using rule 93 (exp -> exp GTEQ exp .)
    )               reduce using rule 93 (exp -> exp GTEQ exp .)
    ,               reduce using rule 93 (exp -> exp GTEQ exp .)
    }               reduce using rule 93 (exp -> exp GTEQ exp .)
    ]               reduce using rule 93 (exp -> exp GTEQ exp .)
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! +               [ reduce using rule 93 (exp -> exp GTEQ exp .) ]
  ! -               [ reduce using rule 93 (exp -> exp GTEQ exp .) ]
  ! *               [ reduce using rule 93 (exp -> exp GTEQ exp .) ]
  ! /               [ reduce using rule 93 (exp -> exp GTEQ exp .) ]
  ! %               [ reduce using rule 93 (exp -> exp GTEQ exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 183

    (105) exp -> exp TSUB ( . identifiers )
    (39) identifiers -> . IDENTIFIER
    (40) identifiers -> . IDENTIFIER , identifiers

    IDENTIFIER      shift and go to state 28

    identifiers                    shift and go to state 211

state 184

    (104) exp -> exp TSUB IDENTIFIER .

    EQ              reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    NEQ             reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    <               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    >               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    LTEQ            reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    GTEQ            reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    +               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    -               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    *               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    /               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    %               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    AND             reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    OR              reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    LSHIFT          reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    TADD            reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    TSUB            reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    ;               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    )               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    ,               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    }               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)
    ]               reduce using rule 104 (exp -> exp TSUB IDENTIFIER .)


state 185

    (101) exp -> exp LSHIFT exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    LSHIFT          reduce using rule 101 (exp -> exp LSHIFT exp .)
    TADD            reduce using rule 101 (exp -> exp LSHIFT exp .)
    TSUB            reduce using rule 101 (exp -> exp LSHIFT exp .)
    ;               reduce using rule 101 (exp -> exp LSHIFT exp .)
    )               reduce using rule 101 (exp -> exp LSHIFT exp .)
    ,               reduce using rule 101 (exp -> exp LSHIFT exp .)
    }               reduce using rule 101 (exp -> exp LSHIFT exp .)
    ]               reduce using rule 101 (exp -> exp LSHIFT exp .)
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163

  ! EQ              [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! NEQ             [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! <               [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! >               [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! LTEQ            [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! GTEQ            [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! +               [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! -               [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! *               [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! /               [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! %               [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! AND             [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! OR              [ reduce using rule 101 (exp -> exp LSHIFT exp .) ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 186

    (103) exp -> exp TADD ( . identifiers )
    (39) identifiers -> . IDENTIFIER
    (40) identifiers -> . IDENTIFIER , identifiers

    IDENTIFIER      shift and go to state 28

    identifiers                    shift and go to state 212

state 187

    (102) exp -> exp TADD IDENTIFIER .

    EQ              reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    NEQ             reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    <               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    >               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    LTEQ            reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    GTEQ            reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    +               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    -               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    *               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    /               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    %               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    AND             reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    OR              reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    LSHIFT          reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    TADD            reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    TSUB            reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    ;               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    )               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    ,               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    }               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)
    ]               reduce using rule 102 (exp -> exp TADD IDENTIFIER .)


state 188

    (89) exp -> exp NEQ exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 89 (exp -> exp NEQ exp .)
    NEQ             reduce using rule 89 (exp -> exp NEQ exp .)
    <               reduce using rule 89 (exp -> exp NEQ exp .)
    >               reduce using rule 89 (exp -> exp NEQ exp .)
    LTEQ            reduce using rule 89 (exp -> exp NEQ exp .)
    GTEQ            reduce using rule 89 (exp -> exp NEQ exp .)
    AND             reduce using rule 89 (exp -> exp NEQ exp .)
    OR              reduce using rule 89 (exp -> exp NEQ exp .)
    LSHIFT          reduce using rule 89 (exp -> exp NEQ exp .)
    TADD            reduce using rule 89 (exp -> exp NEQ exp .)
    TSUB            reduce using rule 89 (exp -> exp NEQ exp .)
    ;               reduce using rule 89 (exp -> exp NEQ exp .)
    )               reduce using rule 89 (exp -> exp NEQ exp .)
    ,               reduce using rule 89 (exp -> exp NEQ exp .)
    }               reduce using rule 89 (exp -> exp NEQ exp .)
    ]               reduce using rule 89 (exp -> exp NEQ exp .)
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! +               [ reduce using rule 89 (exp -> exp NEQ exp .) ]
  ! -               [ reduce using rule 89 (exp -> exp NEQ exp .) ]
  ! *               [ reduce using rule 89 (exp -> exp NEQ exp .) ]
  ! /               [ reduce using rule 89 (exp -> exp NEQ exp .) ]
  ! %               [ reduce using rule 89 (exp -> exp NEQ exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 189

    (98) exp -> exp % exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 98 (exp -> exp % exp .)
    NEQ             reduce using rule 98 (exp -> exp % exp .)
    <               reduce using rule 98 (exp -> exp % exp .)
    >               reduce using rule 98 (exp -> exp % exp .)
    LTEQ            reduce using rule 98 (exp -> exp % exp .)
    GTEQ            reduce using rule 98 (exp -> exp % exp .)
    +               reduce using rule 98 (exp -> exp % exp .)
    -               reduce using rule 98 (exp -> exp % exp .)
    *               reduce using rule 98 (exp -> exp % exp .)
    /               reduce using rule 98 (exp -> exp % exp .)
    %               reduce using rule 98 (exp -> exp % exp .)
    AND             reduce using rule 98 (exp -> exp % exp .)
    OR              reduce using rule 98 (exp -> exp % exp .)
    LSHIFT          reduce using rule 98 (exp -> exp % exp .)
    TADD            reduce using rule 98 (exp -> exp % exp .)
    TSUB            reduce using rule 98 (exp -> exp % exp .)
    ;               reduce using rule 98 (exp -> exp % exp .)
    )               reduce using rule 98 (exp -> exp % exp .)
    ,               reduce using rule 98 (exp -> exp % exp .)
    }               reduce using rule 98 (exp -> exp % exp .)
    ]               reduce using rule 98 (exp -> exp % exp .)

  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! +               [ shift and go to state 153 ]
  ! -               [ shift and go to state 155 ]
  ! *               [ shift and go to state 154 ]
  ! /               [ shift and go to state 156 ]
  ! %               [ shift and go to state 152 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 190

    (94) exp -> exp + exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 94 (exp -> exp + exp .)
    NEQ             reduce using rule 94 (exp -> exp + exp .)
    <               reduce using rule 94 (exp -> exp + exp .)
    >               reduce using rule 94 (exp -> exp + exp .)
    LTEQ            reduce using rule 94 (exp -> exp + exp .)
    GTEQ            reduce using rule 94 (exp -> exp + exp .)
    +               reduce using rule 94 (exp -> exp + exp .)
    -               reduce using rule 94 (exp -> exp + exp .)
    AND             reduce using rule 94 (exp -> exp + exp .)
    OR              reduce using rule 94 (exp -> exp + exp .)
    LSHIFT          reduce using rule 94 (exp -> exp + exp .)
    TADD            reduce using rule 94 (exp -> exp + exp .)
    TSUB            reduce using rule 94 (exp -> exp + exp .)
    ;               reduce using rule 94 (exp -> exp + exp .)
    )               reduce using rule 94 (exp -> exp + exp .)
    ,               reduce using rule 94 (exp -> exp + exp .)
    }               reduce using rule 94 (exp -> exp + exp .)
    ]               reduce using rule 94 (exp -> exp + exp .)
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! *               [ reduce using rule 94 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 94 (exp -> exp + exp .) ]
  ! %               [ reduce using rule 94 (exp -> exp + exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! +               [ shift and go to state 153 ]
  ! -               [ shift and go to state 155 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 191

    (96) exp -> exp * exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 96 (exp -> exp * exp .)
    NEQ             reduce using rule 96 (exp -> exp * exp .)
    <               reduce using rule 96 (exp -> exp * exp .)
    >               reduce using rule 96 (exp -> exp * exp .)
    LTEQ            reduce using rule 96 (exp -> exp * exp .)
    GTEQ            reduce using rule 96 (exp -> exp * exp .)
    +               reduce using rule 96 (exp -> exp * exp .)
    -               reduce using rule 96 (exp -> exp * exp .)
    *               reduce using rule 96 (exp -> exp * exp .)
    /               reduce using rule 96 (exp -> exp * exp .)
    %               reduce using rule 96 (exp -> exp * exp .)
    AND             reduce using rule 96 (exp -> exp * exp .)
    OR              reduce using rule 96 (exp -> exp * exp .)
    LSHIFT          reduce using rule 96 (exp -> exp * exp .)
    TADD            reduce using rule 96 (exp -> exp * exp .)
    TSUB            reduce using rule 96 (exp -> exp * exp .)
    ;               reduce using rule 96 (exp -> exp * exp .)
    )               reduce using rule 96 (exp -> exp * exp .)
    ,               reduce using rule 96 (exp -> exp * exp .)
    }               reduce using rule 96 (exp -> exp * exp .)
    ]               reduce using rule 96 (exp -> exp * exp .)

  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! +               [ shift and go to state 153 ]
  ! -               [ shift and go to state 155 ]
  ! *               [ shift and go to state 154 ]
  ! /               [ shift and go to state 156 ]
  ! %               [ shift and go to state 152 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 192

    (95) exp -> exp - exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 95 (exp -> exp - exp .)
    NEQ             reduce using rule 95 (exp -> exp - exp .)
    <               reduce using rule 95 (exp -> exp - exp .)
    >               reduce using rule 95 (exp -> exp - exp .)
    LTEQ            reduce using rule 95 (exp -> exp - exp .)
    GTEQ            reduce using rule 95 (exp -> exp - exp .)
    +               reduce using rule 95 (exp -> exp - exp .)
    -               reduce using rule 95 (exp -> exp - exp .)
    AND             reduce using rule 95 (exp -> exp - exp .)
    OR              reduce using rule 95 (exp -> exp - exp .)
    LSHIFT          reduce using rule 95 (exp -> exp - exp .)
    TADD            reduce using rule 95 (exp -> exp - exp .)
    TSUB            reduce using rule 95 (exp -> exp - exp .)
    ;               reduce using rule 95 (exp -> exp - exp .)
    )               reduce using rule 95 (exp -> exp - exp .)
    ,               reduce using rule 95 (exp -> exp - exp .)
    }               reduce using rule 95 (exp -> exp - exp .)
    ]               reduce using rule 95 (exp -> exp - exp .)
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! *               [ reduce using rule 95 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 95 (exp -> exp - exp .) ]
  ! %               [ reduce using rule 95 (exp -> exp - exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! +               [ shift and go to state 153 ]
  ! -               [ shift and go to state 155 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 193

    (97) exp -> exp / exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 97 (exp -> exp / exp .)
    NEQ             reduce using rule 97 (exp -> exp / exp .)
    <               reduce using rule 97 (exp -> exp / exp .)
    >               reduce using rule 97 (exp -> exp / exp .)
    LTEQ            reduce using rule 97 (exp -> exp / exp .)
    GTEQ            reduce using rule 97 (exp -> exp / exp .)
    +               reduce using rule 97 (exp -> exp / exp .)
    -               reduce using rule 97 (exp -> exp / exp .)
    *               reduce using rule 97 (exp -> exp / exp .)
    /               reduce using rule 97 (exp -> exp / exp .)
    %               reduce using rule 97 (exp -> exp / exp .)
    AND             reduce using rule 97 (exp -> exp / exp .)
    OR              reduce using rule 97 (exp -> exp / exp .)
    LSHIFT          reduce using rule 97 (exp -> exp / exp .)
    TADD            reduce using rule 97 (exp -> exp / exp .)
    TSUB            reduce using rule 97 (exp -> exp / exp .)
    ;               reduce using rule 97 (exp -> exp / exp .)
    )               reduce using rule 97 (exp -> exp / exp .)
    ,               reduce using rule 97 (exp -> exp / exp .)
    }               reduce using rule 97 (exp -> exp / exp .)
    ]               reduce using rule 97 (exp -> exp / exp .)

  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! +               [ shift and go to state 153 ]
  ! -               [ shift and go to state 155 ]
  ! *               [ shift and go to state 154 ]
  ! /               [ shift and go to state 156 ]
  ! %               [ shift and go to state 152 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 194

    (90) exp -> exp < exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 90 (exp -> exp < exp .)
    NEQ             reduce using rule 90 (exp -> exp < exp .)
    <               reduce using rule 90 (exp -> exp < exp .)
    >               reduce using rule 90 (exp -> exp < exp .)
    LTEQ            reduce using rule 90 (exp -> exp < exp .)
    GTEQ            reduce using rule 90 (exp -> exp < exp .)
    AND             reduce using rule 90 (exp -> exp < exp .)
    OR              reduce using rule 90 (exp -> exp < exp .)
    LSHIFT          reduce using rule 90 (exp -> exp < exp .)
    TADD            reduce using rule 90 (exp -> exp < exp .)
    TSUB            reduce using rule 90 (exp -> exp < exp .)
    ;               reduce using rule 90 (exp -> exp < exp .)
    )               reduce using rule 90 (exp -> exp < exp .)
    ,               reduce using rule 90 (exp -> exp < exp .)
    }               reduce using rule 90 (exp -> exp < exp .)
    ]               reduce using rule 90 (exp -> exp < exp .)
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! +               [ reduce using rule 90 (exp -> exp < exp .) ]
  ! -               [ reduce using rule 90 (exp -> exp < exp .) ]
  ! *               [ reduce using rule 90 (exp -> exp < exp .) ]
  ! /               [ reduce using rule 90 (exp -> exp < exp .) ]
  ! %               [ reduce using rule 90 (exp -> exp < exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 195

    (91) exp -> exp > exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 91 (exp -> exp > exp .)
    NEQ             reduce using rule 91 (exp -> exp > exp .)
    <               reduce using rule 91 (exp -> exp > exp .)
    >               reduce using rule 91 (exp -> exp > exp .)
    LTEQ            reduce using rule 91 (exp -> exp > exp .)
    GTEQ            reduce using rule 91 (exp -> exp > exp .)
    AND             reduce using rule 91 (exp -> exp > exp .)
    OR              reduce using rule 91 (exp -> exp > exp .)
    LSHIFT          reduce using rule 91 (exp -> exp > exp .)
    TADD            reduce using rule 91 (exp -> exp > exp .)
    TSUB            reduce using rule 91 (exp -> exp > exp .)
    ;               reduce using rule 91 (exp -> exp > exp .)
    )               reduce using rule 91 (exp -> exp > exp .)
    ,               reduce using rule 91 (exp -> exp > exp .)
    }               reduce using rule 91 (exp -> exp > exp .)
    ]               reduce using rule 91 (exp -> exp > exp .)
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! +               [ reduce using rule 91 (exp -> exp > exp .) ]
  ! -               [ reduce using rule 91 (exp -> exp > exp .) ]
  ! *               [ reduce using rule 91 (exp -> exp > exp .) ]
  ! /               [ reduce using rule 91 (exp -> exp > exp .) ]
  ! %               [ reduce using rule 91 (exp -> exp > exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 196

    (88) exp -> exp EQ exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 88 (exp -> exp EQ exp .)
    NEQ             reduce using rule 88 (exp -> exp EQ exp .)
    <               reduce using rule 88 (exp -> exp EQ exp .)
    >               reduce using rule 88 (exp -> exp EQ exp .)
    LTEQ            reduce using rule 88 (exp -> exp EQ exp .)
    GTEQ            reduce using rule 88 (exp -> exp EQ exp .)
    AND             reduce using rule 88 (exp -> exp EQ exp .)
    OR              reduce using rule 88 (exp -> exp EQ exp .)
    LSHIFT          reduce using rule 88 (exp -> exp EQ exp .)
    TADD            reduce using rule 88 (exp -> exp EQ exp .)
    TSUB            reduce using rule 88 (exp -> exp EQ exp .)
    ;               reduce using rule 88 (exp -> exp EQ exp .)
    )               reduce using rule 88 (exp -> exp EQ exp .)
    ,               reduce using rule 88 (exp -> exp EQ exp .)
    }               reduce using rule 88 (exp -> exp EQ exp .)
    ]               reduce using rule 88 (exp -> exp EQ exp .)
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! +               [ reduce using rule 88 (exp -> exp EQ exp .) ]
  ! -               [ reduce using rule 88 (exp -> exp EQ exp .) ]
  ! *               [ reduce using rule 88 (exp -> exp EQ exp .) ]
  ! /               [ reduce using rule 88 (exp -> exp EQ exp .) ]
  ! %               [ reduce using rule 88 (exp -> exp EQ exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 197

    (99) exp -> exp AND exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    AND             reduce using rule 99 (exp -> exp AND exp .)
    OR              reduce using rule 99 (exp -> exp AND exp .)
    LSHIFT          reduce using rule 99 (exp -> exp AND exp .)
    TADD            reduce using rule 99 (exp -> exp AND exp .)
    TSUB            reduce using rule 99 (exp -> exp AND exp .)
    ;               reduce using rule 99 (exp -> exp AND exp .)
    )               reduce using rule 99 (exp -> exp AND exp .)
    ,               reduce using rule 99 (exp -> exp AND exp .)
    }               reduce using rule 99 (exp -> exp AND exp .)
    ]               reduce using rule 99 (exp -> exp AND exp .)
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! EQ              [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! NEQ             [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! <               [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! >               [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! LTEQ            [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! GTEQ            [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! +               [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! -               [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! *               [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! /               [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! %               [ reduce using rule 99 (exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 198

    (92) exp -> exp LTEQ exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    EQ              reduce using rule 92 (exp -> exp LTEQ exp .)
    NEQ             reduce using rule 92 (exp -> exp LTEQ exp .)
    <               reduce using rule 92 (exp -> exp LTEQ exp .)
    >               reduce using rule 92 (exp -> exp LTEQ exp .)
    LTEQ            reduce using rule 92 (exp -> exp LTEQ exp .)
    GTEQ            reduce using rule 92 (exp -> exp LTEQ exp .)
    AND             reduce using rule 92 (exp -> exp LTEQ exp .)
    OR              reduce using rule 92 (exp -> exp LTEQ exp .)
    LSHIFT          reduce using rule 92 (exp -> exp LTEQ exp .)
    TADD            reduce using rule 92 (exp -> exp LTEQ exp .)
    TSUB            reduce using rule 92 (exp -> exp LTEQ exp .)
    ;               reduce using rule 92 (exp -> exp LTEQ exp .)
    )               reduce using rule 92 (exp -> exp LTEQ exp .)
    ,               reduce using rule 92 (exp -> exp LTEQ exp .)
    }               reduce using rule 92 (exp -> exp LTEQ exp .)
    ]               reduce using rule 92 (exp -> exp LTEQ exp .)
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! +               [ reduce using rule 92 (exp -> exp LTEQ exp .) ]
  ! -               [ reduce using rule 92 (exp -> exp LTEQ exp .) ]
  ! *               [ reduce using rule 92 (exp -> exp LTEQ exp .) ]
  ! /               [ reduce using rule 92 (exp -> exp LTEQ exp .) ]
  ! %               [ reduce using rule 92 (exp -> exp LTEQ exp .) ]
  ! EQ              [ shift and go to state 160 ]
  ! NEQ             [ shift and go to state 151 ]
  ! <               [ shift and go to state 158 ]
  ! >               [ shift and go to state 159 ]
  ! LTEQ            [ shift and go to state 162 ]
  ! GTEQ            [ shift and go to state 147 ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 199

    (100) exp -> exp OR exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    AND             reduce using rule 100 (exp -> exp OR exp .)
    OR              reduce using rule 100 (exp -> exp OR exp .)
    LSHIFT          reduce using rule 100 (exp -> exp OR exp .)
    TADD            reduce using rule 100 (exp -> exp OR exp .)
    TSUB            reduce using rule 100 (exp -> exp OR exp .)
    ;               reduce using rule 100 (exp -> exp OR exp .)
    )               reduce using rule 100 (exp -> exp OR exp .)
    ,               reduce using rule 100 (exp -> exp OR exp .)
    }               reduce using rule 100 (exp -> exp OR exp .)
    ]               reduce using rule 100 (exp -> exp OR exp .)
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152

  ! EQ              [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! NEQ             [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! <               [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! >               [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! LTEQ            [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! GTEQ            [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! +               [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! -               [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! *               [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! /               [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! %               [ reduce using rule 100 (exp -> exp OR exp .) ]
  ! AND             [ shift and go to state 161 ]
  ! OR              [ shift and go to state 163 ]
  ! LSHIFT          [ shift and go to state 149 ]
  ! TADD            [ shift and go to state 150 ]
  ! TSUB            [ shift and go to state 148 ]


state 200

    (115) exp -> ( exp ) .

    EQ              reduce using rule 115 (exp -> ( exp ) .)
    NEQ             reduce using rule 115 (exp -> ( exp ) .)
    <               reduce using rule 115 (exp -> ( exp ) .)
    >               reduce using rule 115 (exp -> ( exp ) .)
    LTEQ            reduce using rule 115 (exp -> ( exp ) .)
    GTEQ            reduce using rule 115 (exp -> ( exp ) .)
    +               reduce using rule 115 (exp -> ( exp ) .)
    -               reduce using rule 115 (exp -> ( exp ) .)
    *               reduce using rule 115 (exp -> ( exp ) .)
    /               reduce using rule 115 (exp -> ( exp ) .)
    %               reduce using rule 115 (exp -> ( exp ) .)
    AND             reduce using rule 115 (exp -> ( exp ) .)
    OR              reduce using rule 115 (exp -> ( exp ) .)
    LSHIFT          reduce using rule 115 (exp -> ( exp ) .)
    TADD            reduce using rule 115 (exp -> ( exp ) .)
    TSUB            reduce using rule 115 (exp -> ( exp ) .)
    ;               reduce using rule 115 (exp -> ( exp ) .)
    )               reduce using rule 115 (exp -> ( exp ) .)
    ,               reduce using rule 115 (exp -> ( exp ) .)
    }               reduce using rule 115 (exp -> ( exp ) .)
    ]               reduce using rule 115 (exp -> ( exp ) .)


state 201

    (71) stm -> WHILE ( exp ) . stm
    (64) stm -> . ;
    (65) stm -> . SHOW document receive ;
    (66) stm -> . EXIT document ;
    (67) stm -> . RETURN ;
    (68) stm -> . RETURN exp ;
    (69) stm -> . IF ( exp ) stm
    (70) stm -> . IF ( exp ) stm ELSE stm
    (71) stm -> . WHILE ( exp ) stm
    (72) stm -> . compoundstm
    (73) stm -> . exp ;
    (78) compoundstm -> . { variables stms }
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    ;               shift and go to state 114
    SHOW            shift and go to state 116
    EXIT            shift and go to state 125
    RETURN          shift and go to state 108
    IF              shift and go to state 119
    WHILE           shift and go to state 109
    {               shift and go to state 98
    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    stm                            shift and go to state 213
    exp                            shift and go to state 126
    compoundstm                    shift and go to state 110

state 202

    (75) document -> PLUG IDENTIFIER [ . plugs ]
    (79) plugs -> . plug
    (80) plugs -> . plug , plugs
    (81) plug -> . IDENTIFIER = exp

    IDENTIFIER      shift and go to state 215

    plug                           shift and go to state 214
    plugs                          shift and go to state 216

state 203

    (65) stm -> SHOW document receive ; .

    ;               reduce using rule 65 (stm -> SHOW document receive ; .)
    SHOW            reduce using rule 65 (stm -> SHOW document receive ; .)
    EXIT            reduce using rule 65 (stm -> SHOW document receive ; .)
    RETURN          reduce using rule 65 (stm -> SHOW document receive ; .)
    IF              reduce using rule 65 (stm -> SHOW document receive ; .)
    WHILE           reduce using rule 65 (stm -> SHOW document receive ; .)
    {               reduce using rule 65 (stm -> SHOW document receive ; .)
    -               reduce using rule 65 (stm -> SHOW document receive ; .)
    !               reduce using rule 65 (stm -> SHOW document receive ; .)
    IDENTIFIER      reduce using rule 65 (stm -> SHOW document receive ; .)
    STRING_LITERAL  reduce using rule 65 (stm -> SHOW document receive ; .)
    TRUE            reduce using rule 65 (stm -> SHOW document receive ; .)
    FALSE           reduce using rule 65 (stm -> SHOW document receive ; .)
    INT_LITERAL     reduce using rule 65 (stm -> SHOW document receive ; .)
    TUPLE           reduce using rule 65 (stm -> SHOW document receive ; .)
    (               reduce using rule 65 (stm -> SHOW document receive ; .)
    }               reduce using rule 65 (stm -> SHOW document receive ; .)
    ELSE            reduce using rule 65 (stm -> SHOW document receive ; .)


state 204

    (77) receive -> RECEIVE [ . inputs ]
    (82) inputs -> .
    (83) inputs -> . neinputs
    (84) neinputs -> . input
    (85) neinputs -> . input , neinputs
    (86) input -> . lvalue = IDENTIFIER
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    ]               reduce using rule 82 (inputs -> .)
    IDENTIFIER      shift and go to state 221

    neinputs                       shift and go to state 219
    inputs                         shift and go to state 217
    lvalue                         shift and go to state 218
    input                          shift and go to state 220

state 205

    (69) stm -> IF ( exp ) . stm
    (70) stm -> IF ( exp ) . stm ELSE stm
    (64) stm -> . ;
    (65) stm -> . SHOW document receive ;
    (66) stm -> . EXIT document ;
    (67) stm -> . RETURN ;
    (68) stm -> . RETURN exp ;
    (69) stm -> . IF ( exp ) stm
    (70) stm -> . IF ( exp ) stm ELSE stm
    (71) stm -> . WHILE ( exp ) stm
    (72) stm -> . compoundstm
    (73) stm -> . exp ;
    (78) compoundstm -> . { variables stms }
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    ;               shift and go to state 114
    SHOW            shift and go to state 116
    EXIT            shift and go to state 125
    RETURN          shift and go to state 108
    IF              shift and go to state 119
    WHILE           shift and go to state 109
    {               shift and go to state 98
    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    stm                            shift and go to state 222
    exp                            shift and go to state 126
    compoundstm                    shift and go to state 110

state 206

    (109) exp -> IDENTIFIER ( exps ) .

    EQ              reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    NEQ             reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    <               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    >               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    LTEQ            reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    GTEQ            reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    +               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    -               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    *               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    /               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    %               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    AND             reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    OR              reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    LSHIFT          reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    TADD            reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    TSUB            reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    ;               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    )               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    ,               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    }               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)
    ]               reduce using rule 109 (exp -> IDENTIFIER ( exps ) .)


state 207

    (119) neexps -> exp , . neexps
    (118) neexps -> . exp
    (119) neexps -> . exp , neexps
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    neexps                         shift and go to state 223
    lvalue                         shift and go to state 112
    exp                            shift and go to state 175

state 208

    (114) exp -> TUPLE { fieldvalues } .

    EQ              reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    NEQ             reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    <               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    >               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    LTEQ            reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    GTEQ            reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    +               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    -               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    *               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    /               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    %               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    AND             reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    OR              reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    LSHIFT          reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    TADD            reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    TSUB            reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    ;               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    )               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    ,               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    }               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)
    ]               reduce using rule 114 (exp -> TUPLE { fieldvalues } .)


state 209

    (126) fieldvalue -> IDENTIFIER = . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 224

state 210

    (125) nefieldvalues -> fieldvalue , . fieldvalues
    (122) fieldvalues -> .
    (123) fieldvalues -> . nefieldvalues
    (124) nefieldvalues -> . fieldvalue
    (125) nefieldvalues -> . fieldvalue , fieldvalues
    (126) fieldvalue -> . IDENTIFIER = exp

    }               reduce using rule 122 (fieldvalues -> .)
    IDENTIFIER      shift and go to state 179

    nefieldvalues                  shift and go to state 177
    fieldvalue                     shift and go to state 180
    fieldvalues                    shift and go to state 225

state 211

    (105) exp -> exp TSUB ( identifiers . )

    )               shift and go to state 226


state 212

    (103) exp -> exp TADD ( identifiers . )

    )               shift and go to state 227


state 213

    (71) stm -> WHILE ( exp ) stm .

    ;               reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    SHOW            reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    EXIT            reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    RETURN          reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    IF              reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    WHILE           reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    {               reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    -               reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    !               reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    IDENTIFIER      reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    STRING_LITERAL  reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    TRUE            reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    FALSE           reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    INT_LITERAL     reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    TUPLE           reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    (               reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    }               reduce using rule 71 (stm -> WHILE ( exp ) stm .)
    ELSE            reduce using rule 71 (stm -> WHILE ( exp ) stm .)


state 214

    (79) plugs -> plug .
    (80) plugs -> plug . , plugs

    ]               reduce using rule 79 (plugs -> plug .)
    ,               shift and go to state 228


state 215

    (81) plug -> IDENTIFIER . = exp

    =               shift and go to state 229


state 216

    (75) document -> PLUG IDENTIFIER [ plugs . ]

    ]               shift and go to state 230


state 217

    (77) receive -> RECEIVE [ inputs . ]

    ]               shift and go to state 231


state 218

    (86) input -> lvalue . = IDENTIFIER

    =               shift and go to state 232


state 219

    (83) inputs -> neinputs .

    ]               reduce using rule 83 (inputs -> neinputs .)


state 220

    (84) neinputs -> input .
    (85) neinputs -> input . , neinputs

    ]               reduce using rule 84 (neinputs -> input .)
    ,               shift and go to state 233


state 221

    (120) lvalue -> IDENTIFIER .
    (121) lvalue -> IDENTIFIER . . IDENTIFIER

    =               reduce using rule 120 (lvalue -> IDENTIFIER .)
    .               shift and go to state 143


state 222

    (69) stm -> IF ( exp ) stm .
    (70) stm -> IF ( exp ) stm . ELSE stm

  ! shift/reduce conflict for ELSE resolved as shift
    ;               reduce using rule 69 (stm -> IF ( exp ) stm .)
    SHOW            reduce using rule 69 (stm -> IF ( exp ) stm .)
    EXIT            reduce using rule 69 (stm -> IF ( exp ) stm .)
    RETURN          reduce using rule 69 (stm -> IF ( exp ) stm .)
    IF              reduce using rule 69 (stm -> IF ( exp ) stm .)
    WHILE           reduce using rule 69 (stm -> IF ( exp ) stm .)
    {               reduce using rule 69 (stm -> IF ( exp ) stm .)
    -               reduce using rule 69 (stm -> IF ( exp ) stm .)
    !               reduce using rule 69 (stm -> IF ( exp ) stm .)
    IDENTIFIER      reduce using rule 69 (stm -> IF ( exp ) stm .)
    STRING_LITERAL  reduce using rule 69 (stm -> IF ( exp ) stm .)
    TRUE            reduce using rule 69 (stm -> IF ( exp ) stm .)
    FALSE           reduce using rule 69 (stm -> IF ( exp ) stm .)
    INT_LITERAL     reduce using rule 69 (stm -> IF ( exp ) stm .)
    TUPLE           reduce using rule 69 (stm -> IF ( exp ) stm .)
    (               reduce using rule 69 (stm -> IF ( exp ) stm .)
    }               reduce using rule 69 (stm -> IF ( exp ) stm .)
    ELSE            shift and go to state 234

  ! ELSE            [ reduce using rule 69 (stm -> IF ( exp ) stm .) ]


state 223

    (119) neexps -> exp , neexps .

    )               reduce using rule 119 (neexps -> exp , neexps .)


state 224

    (126) fieldvalue -> IDENTIFIER = exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    ,               reduce using rule 126 (fieldvalue -> IDENTIFIER = exp .)
    }               reduce using rule 126 (fieldvalue -> IDENTIFIER = exp .)
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163
    LSHIFT          shift and go to state 149
    TADD            shift and go to state 150
    TSUB            shift and go to state 148


state 225

    (125) nefieldvalues -> fieldvalue , fieldvalues .

    }               reduce using rule 125 (nefieldvalues -> fieldvalue , fieldvalues .)


state 226

    (105) exp -> exp TSUB ( identifiers ) .

    EQ              reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    NEQ             reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    <               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    >               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    LTEQ            reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    GTEQ            reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    +               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    -               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    *               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    /               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    %               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    AND             reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    OR              reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    LSHIFT          reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    TADD            reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    TSUB            reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    ;               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    )               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    ,               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    }               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)
    ]               reduce using rule 105 (exp -> exp TSUB ( identifiers ) .)


state 227

    (103) exp -> exp TADD ( identifiers ) .

    EQ              reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    NEQ             reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    <               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    >               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    LTEQ            reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    GTEQ            reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    +               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    -               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    *               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    /               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    %               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    AND             reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    OR              reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    LSHIFT          reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    TADD            reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    TSUB            reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    ;               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    )               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    ,               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    }               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)
    ]               reduce using rule 103 (exp -> exp TADD ( identifiers ) .)


state 228

    (80) plugs -> plug , . plugs
    (79) plugs -> . plug
    (80) plugs -> . plug , plugs
    (81) plug -> . IDENTIFIER = exp

    IDENTIFIER      shift and go to state 215

    plug                           shift and go to state 214
    plugs                          shift and go to state 235

state 229

    (81) plug -> IDENTIFIER = . exp
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    exp                            shift and go to state 236

state 230

    (75) document -> PLUG IDENTIFIER [ plugs ] .

    RECEIVE         reduce using rule 75 (document -> PLUG IDENTIFIER [ plugs ] .)
    ;               reduce using rule 75 (document -> PLUG IDENTIFIER [ plugs ] .)


state 231

    (77) receive -> RECEIVE [ inputs ] .

    ;               reduce using rule 77 (receive -> RECEIVE [ inputs ] .)


state 232

    (86) input -> lvalue = . IDENTIFIER

    IDENTIFIER      shift and go to state 237


state 233

    (85) neinputs -> input , . neinputs
    (84) neinputs -> . input
    (85) neinputs -> . input , neinputs
    (86) input -> . lvalue = IDENTIFIER
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    IDENTIFIER      shift and go to state 221

    neinputs                       shift and go to state 238
    input                          shift and go to state 220
    lvalue                         shift and go to state 218

state 234

    (70) stm -> IF ( exp ) stm ELSE . stm
    (64) stm -> . ;
    (65) stm -> . SHOW document receive ;
    (66) stm -> . EXIT document ;
    (67) stm -> . RETURN ;
    (68) stm -> . RETURN exp ;
    (69) stm -> . IF ( exp ) stm
    (70) stm -> . IF ( exp ) stm ELSE stm
    (71) stm -> . WHILE ( exp ) stm
    (72) stm -> . compoundstm
    (73) stm -> . exp ;
    (78) compoundstm -> . { variables stms }
    (87) exp -> . lvalue = exp
    (88) exp -> . exp EQ exp
    (89) exp -> . exp NEQ exp
    (90) exp -> . exp < exp
    (91) exp -> . exp > exp
    (92) exp -> . exp LTEQ exp
    (93) exp -> . exp GTEQ exp
    (94) exp -> . exp + exp
    (95) exp -> . exp - exp
    (96) exp -> . exp * exp
    (97) exp -> . exp / exp
    (98) exp -> . exp % exp
    (99) exp -> . exp AND exp
    (100) exp -> . exp OR exp
    (101) exp -> . exp LSHIFT exp
    (102) exp -> . exp TADD IDENTIFIER
    (103) exp -> . exp TADD ( identifiers )
    (104) exp -> . exp TSUB IDENTIFIER
    (105) exp -> . exp TSUB ( identifiers )
    (106) exp -> . - exp
    (107) exp -> . ! exp
    (108) exp -> . lvalue
    (109) exp -> . IDENTIFIER ( exps )
    (110) exp -> . STRING_LITERAL
    (111) exp -> . TRUE
    (112) exp -> . FALSE
    (113) exp -> . INT_LITERAL
    (114) exp -> . TUPLE { fieldvalues }
    (115) exp -> . ( exp )
    (120) lvalue -> . IDENTIFIER
    (121) lvalue -> . IDENTIFIER . IDENTIFIER

    ;               shift and go to state 114
    SHOW            shift and go to state 116
    EXIT            shift and go to state 125
    RETURN          shift and go to state 108
    IF              shift and go to state 119
    WHILE           shift and go to state 109
    {               shift and go to state 98
    -               shift and go to state 113
    !               shift and go to state 115
    IDENTIFIER      shift and go to state 120
    STRING_LITERAL  shift and go to state 122
    TRUE            shift and go to state 118
    FALSE           shift and go to state 121
    INT_LITERAL     shift and go to state 128
    TUPLE           shift and go to state 123
    (               shift and go to state 127

    lvalue                         shift and go to state 112
    stm                            shift and go to state 239
    exp                            shift and go to state 126
    compoundstm                    shift and go to state 110

state 235

    (80) plugs -> plug , plugs .

    ]               reduce using rule 80 (plugs -> plug , plugs .)


state 236

    (81) plug -> IDENTIFIER = exp .
    (88) exp -> exp . EQ exp
    (89) exp -> exp . NEQ exp
    (90) exp -> exp . < exp
    (91) exp -> exp . > exp
    (92) exp -> exp . LTEQ exp
    (93) exp -> exp . GTEQ exp
    (94) exp -> exp . + exp
    (95) exp -> exp . - exp
    (96) exp -> exp . * exp
    (97) exp -> exp . / exp
    (98) exp -> exp . % exp
    (99) exp -> exp . AND exp
    (100) exp -> exp . OR exp
    (101) exp -> exp . LSHIFT exp
    (102) exp -> exp . TADD IDENTIFIER
    (103) exp -> exp . TADD ( identifiers )
    (104) exp -> exp . TSUB IDENTIFIER
    (105) exp -> exp . TSUB ( identifiers )

    ,               reduce using rule 81 (plug -> IDENTIFIER = exp .)
    ]               reduce using rule 81 (plug -> IDENTIFIER = exp .)
    EQ              shift and go to state 160
    NEQ             shift and go to state 151
    <               shift and go to state 158
    >               shift and go to state 159
    LTEQ            shift and go to state 162
    GTEQ            shift and go to state 147
    +               shift and go to state 153
    -               shift and go to state 155
    *               shift and go to state 154
    /               shift and go to state 156
    %               shift and go to state 152
    AND             shift and go to state 161
    OR              shift and go to state 163
    LSHIFT          shift and go to state 149
    TADD            shift and go to state 150
    TSUB            shift and go to state 148


state 237

    (86) input -> lvalue = IDENTIFIER .

    ,               reduce using rule 86 (input -> lvalue = IDENTIFIER .)
    ]               reduce using rule 86 (input -> lvalue = IDENTIFIER .)


state 238

    (85) neinputs -> input , neinputs .

    ]               reduce using rule 85 (neinputs -> input , neinputs .)


state 239

    (70) stm -> IF ( exp ) stm ELSE stm .

    ;               reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    SHOW            reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    EXIT            reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    RETURN          reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    IF              reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    WHILE           reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    {               reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    -               reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    !               reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    IDENTIFIER      reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    STRING_LITERAL  reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    TRUE            reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    FALSE           reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    INT_LITERAL     reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    TUPLE           reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    (               reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    }               reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)
    ELSE            reduce using rule 70 (stm -> IF ( exp ) stm ELSE stm .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TUPLE in state 12 resolved as shift
WARNING: shift/reduce conflict for INT in state 12 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 12 resolved as shift
WARNING: shift/reduce conflict for STRING in state 12 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: shift/reduce conflict for TUPLE in state 25 resolved as shift
WARNING: shift/reduce conflict for INT in state 25 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 25 resolved as shift
WARNING: shift/reduce conflict for STRING in state 25 resolved as shift
WARNING: shift/reduce conflict for VOID in state 25 resolved as shift
WARNING: shift/reduce conflict for START_CLOSE_TAG in state 52 resolved as shift
WARNING: shift/reduce conflict for TUPLE in state 98 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 222 resolved as shift
